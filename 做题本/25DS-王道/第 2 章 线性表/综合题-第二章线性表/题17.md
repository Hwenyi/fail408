## 题17
### 题目
【2009 统考真题】已知一个带有表头结点的单链表，结点结构为$\begin{array}{|c|c|} \hline \text{data} & \text{link}\\\hline \end{array}$ ，假设该链表只给出了头指针 $\rm list$ 。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第 $k$ 个位置上的结点（ $k$ 为正整数）。若查找成功，算法输出该结点的 $\rm data$ 域的值，并返回 $1$ ；否则，只返回 $0$ 。要求：

⑴ 描述算法的基本设计思想。

⑵ 描述算法的详细实现步骤。

⑶ 根据设计思想和实现步骤，采用程序设计语言描述算法（使用 C 或 C++ 或 Java 语言实现），关键之处请给出简要注释。
### 分析
[[刷题/408真题分类/DS真题/第 2 章线性表/2.2 线性表的链式存储/题5]]
### 解
[[刷题/408历年真题解析/2009年408真题数据结构篇/题42]]
1) 算法的基本设计思想如下:

问题的关键是设计一个尽可能高效的算法,通过链表的一次遍历,找到倒数第 $k$ 个结点的位置。算法的基本设计思想是: 定义两个指针变量 `p` 和 `q` ,初始时均指向头结点的下一个结点 (链表的第一个结点), `p` 指针沿链表移动; 当 `p` 指针移动到第 $k$ 个结点时, `q` 指针开始与 `p` 指针同步移动; 当 `p` 指针移动到最后一个结点时, `q` 指针所指示结点为倒数第 $k$ 个结点。以上过程对链表仅进行一遍扫描。

2) 算法的详细实现步骤如下:

① `count = 0`, `p` 和 `q` 指向链表表头结点的下一个结点。

② 若 `p` 为空,转⑤。

③ 若 `count` 等于 `k` ,则 `q` 指向下一个结点; 否则,`count = count + 1`。

④ `p` 指向下一个结点,转②。

⑤ 若 `count` 等于 `k` ,则查找成功,输出该结点的 `data` 域的值,返回 `1` ; 否则,说明 `k` 值超过了线性表的长度, 查找失败, 返回 `0` 。

⑥ 算法结束。

3) 算法实现如下:

```c
typedef int ElemType; //链表数据的类型定义

typedef struct LNode {
    ElemType data; //结点数据
    struct LNode *link; //结点链接指针
} LNode, *LinkList;

int Search_k(LinkList list, int k) {
    LNode *p = list->link, *q = list->link; //指针 p、q 指示第一个结点
    int count = 0;

    while (p != NULL) { //遍历链表直到最后一个结点
        if (count < k) count++; //计数,若 count < k 只移动 p
        else q = q->link;

        p = p->link; //之后让 p、q 同步移动
    }

    if (count < k)
        return 0; //查找失败返回 0
    else { //否则打印并返回 1
        printf("%d", q->data);
        return 1;
    }
}