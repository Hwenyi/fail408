---
publish: true
tags: []
aliases: 
finished: true
TARGET DECK: 刷题::25DS-王道::第 1 章 绪论::1.2 算法和算法评价::anki
title: anki
created: "2024-10-12 18:17"
updated: "2024-10-12 18:18"
---

Q: 在分析算法时间复杂度时，加法规则是什么？它如何应用于代码分析？
A: 如果一个算法由多个步骤组成，每个步骤的时间复杂度分别为 T1(n) 和 T2(n)，那么整个算法的时间复杂度是 T1(n) 和 T2(n) 中较大者的量级。
补充细节： 简单来说，加法规则意味着算法的总时间复杂度取决于执行时间最长的部分。 例如，如果一个算法的一部分需要 O(n) 的时间，而另一部分需要 O(n^2) 的时间，那么整个算法的时间复杂度就是 O(n^2)。
<!--ID: 1725344113805-->

Q: 在分析算法时间复杂度时，乘法规则是什么？它通常在什么情况下使用？
A: 如果一个算法包含嵌套循环，其中外层循环执行 f(n) 次，内层循环执行 g(n) 次，那么整个算法的时间复杂度就是 O(f(n) * g(n))。
补充细节： 乘法规则通常用于分析嵌套循环的时间复杂度。  
例如，如果有两层嵌套循环，每层循环都执行 n 次，那么整个算法的时间复杂度就是 O(n * n) = O(n^2)。
<!--ID: 1725344113811-->

Q: 列举一些常见的渐近时间复杂度，并按照效率从高到低排序。你能否给出每种复杂度对应的典型算法示例？
A: $O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)$
补充细节：
- O(1): 常数时间复杂度，例如访问数组元素。
- O(log n): 对数时间复杂度，例如二分查找。
- O(n): 线性时间复杂度，例如线性查找。
- O(n log n): 线性对数时间复杂度，例如快速排序、归并排序。
- O(n^2): 平方时间复杂度，例如冒泡排序、选择排序、插入排序。
- O(n^3): 立方时间复杂度，例如矩阵乘法。
- O(2^n): 指数时间复杂度，例如暴力破解旅行商问题。
- O(n!): 阶乘时间复杂度，例如暴力破解排列问题。
- O(n^n): 例如枚举所有子集。
口诀记忆：**常对幂指阶**，分别代表 常数、对数、多项式、指数、阶乘。
<!--ID: 1725344113817-->

Q: 什么是原地工作(in-place)的算法？你能否举几个例子？
A: 如果一个算法的空间复杂度为 O(1)，也就是说，它只需要常数大小的额外存储空间，那么就称这个算法是原地工作的。
补充细节： 原地工作的算法直接在输入数据上进行操作，而不需要额外的辅助空间。  
例如，交换两个变量的值、以及一些高效的排序算法（如快速排序的某些实现）都是原地工作的。  
原地工作的算法具有空间效率高的优势，特别适用于内存资源有限的场景。
<!--ID: 1725344113823-->