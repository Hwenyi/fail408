---
publish: true
tags:
  - 计组
  - 指令
  - 寻址
  - 补码
  - 做错了
  - 题目/选择题
  - 地址
aliases: 
finished: 
title: 题21
created: 2024-07-20 18:04
updated: 2024-09-21 07:01
TARGET DECK: 刷题::25计组-王道::第 4 章 指令系统::4.2 指令的寻址方式::题21
---
## 题21
### 题目
Q:设相对寻址的转移指令占 $3\mathrm{\;B}$ ,第一字节为操作码,第二、三字节为相对位移量 (补码表示), 而且数据在存储器中采用以低字节为字地址的存放方式。
每当 CPU 从存储器取出一字节时,即自动完成(PC) $+ 1 \rightarrow$ PC。
若PC的当前值为 240 (十进制),要求转移到 290 (十进制), 则转移指令的第二、三字节的机器代码是 ();
若 $\mathrm{{PC}}$ 的当前值为 240 (十进制),要求转移到 200 (十进制), 则转移指令的第二、三字节的机器代码是 ( )。
A. $2\mathrm{{FH}}\text{、}\mathrm{{FFH}}$ 
B. D5H、00H 
C. D5H、FFH 
D. $2\mathrm{{FH}}\text{、}{00}\mathrm{H}$
### 分析
A:每次PC加的1，加的都是指令的长度，这里的指令长度是3B，也就是加3，之前也做到过这种类似的题目结构，也就是[[刷题/25计组-王道/第 4 章 指令系统/4.2 指令的寻址方式/题16]]里面说的，这里的指令字长是给的bit，也就是位，16位，也就是2B，那么PC就是移动2个B
### 解
D、C
首先需要讲解一下补码扩充的问题。补码的扩充只需使用符号位补足即可, 也就是说正数补码的扩充只要补 0 , 负数补码的扩充只需补 1 (这是由补码的性质决定的)。
理解了该性质, 这道题就变成了十进制转换为十六进制的简单问题。
1. ${PC}$ 的当前值为 240,该指令取出后 ${PC}$ 的值为 243,要求转移到 290,即相对位移量为 ${290} - {243} = {47}$ ,转换成补码为 $2{FH}$ 。由于数据在存储器中采用以低字节地址为字地址的存放方式,因此该转移指令的第二字节为 $2{FH}$ ,由于 47 是正数,因此只需在高位补 0, 所以第三字节为 ${00}H$ 。
2. ${PC}$ 的当前值为 240,该指令取出后 ${PC}$ 的值为 243,要求转移到 200,即相对位移量为 ${200} - {243} =  - {43}$ ,转换成补码为 $D5H$ 。由于数据在存储器中采用以低字节地址为字地址的存放方式,因此该转移指令的第二字节为 $D5H$ ,由于 -43 是负数,因此只需在高位补 1, 所以第三字节为 FFH。


