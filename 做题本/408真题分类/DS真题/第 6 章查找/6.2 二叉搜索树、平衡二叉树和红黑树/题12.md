---
publish: true
tags:
  - 做错了
aliases: 
finished: true
title: 题12
created: 2024-10-29 11:58
updated: 2024-11-14 12:32
TARGET DECK: 刷题::408真题分类::DS真题::第 6 章查找::6.2 二叉搜索树、平衡二叉树和红黑树::题12
error: true
---
## 题12
### 题目
> [!error]+
> 【2022】已知非空二叉树T的结点值均为正整数, 采用顺序存储方式保存, 数据结构定义如下:
> ```cpp
> typedef struct {
>     int SqBiTNode[MAX_SIZE]; // 保存二叉树结点值的数组
>     int ElemNum; // 实际占用的数组元素个数
> } SqBiTree;
> ```
> T中不存在的结点在数组 SqBiTNode 中用-1 表示。例如, 对于下图所示的两棵非空二叉树 T1 和 T2:
> ![](https://img.hwenyi.live/202410301848964.webp)
> T1 的存储结果如下:
> ![](https://img.hwenyi.live/202410301848052.webp)
> T2 的存储结果如下:
> ![](https://img.hwenyi.live/202410301848732.webp)
> 请设计算法, 并设计算法, 判定一个尽可能高效的算法, 判定一棵采用这种方式存储的二叉树是否为二叉搜索树, 若是, 则返回 true, 否则, 返回 false。要求: 
> (1) 给出算法的基本设计思想。
> (2) 根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释。
### 分析
> [!NOTE]+
> [[二叉排序树-aw|二叉搜索树]]是覆盖删除，利用后面的覆盖要删除的，同时尽量维持，左小右大，为了可以维持住，我们希望覆盖上来的和原节点的值是差不多的
> 考虑[[二叉排序树-aw|二叉搜索树]]的一个重要性质就是，[[中序遍历]]的结果是一个升序序列，因为中序会把左侧先输出完（左边都是小的）然后第一次退栈，输出根，接着递归右边，右在右边中递归中序遍历，给出右边的左边，使得升序序列可以连贯上
> 这里如果输出的是升序序列，那么就是二叉搜索树，如果不是，那么就不是
> 现在问题的关键是，如何读入这样存储的元素，这里通过把树结构的编号标出来，再把数组下标标出来，然后对比模拟，归纳出来规律
### 解
> [!done]+
> [[刷题/408历年真题解析/2022年408真题数据结构篇/题41]]
> 1. 这里不用像leetcode一样实现，只需要描述思路
> 通过中序遍历，把每次遍历的节点记录在一个数组中，最后验证数组是否是升序的
> 2. 描述
> ```cpp
> bool is_valid(SqBiTree tree) {
> 	//存遍历结果的数组
> 	int num[100000], len = 0;
> 	//遍历这个树
> 	inOrder(tree, num, &len, 0);
> 	//现在拿到了遍历结果，验证是否是升序
> 	for (int i = 1; i < len; i++) {
>     if (num[i] < num[i - 1]) return false;
>   } else return true;
>   //现在实现中序遍历，这里要明确题目的数组是如何存储数据的
> 	void InOrder(SqBiTree tree, int *num, int *len, int i) //tree是这个树，num是存储遍历结果的数组，len是数组的长度，i是当前遍历的节点
> 	{
> 		if (i >= tree.ElemNum) return;
> 		InOrder(tree, num, len, 2 * i + 1); //左
> 		num[*len] = tree.SqBiTNode[i];
> 		(*len)++;
> 		InOrder(tree, num, len, 2 * i + 2); //右
> 	}
> }
> ```
> 
> 如果在[[二叉树]]的遍历过程中取节点值，记住这个操作;;`num[*len] = tree.SqBiTNode[i]; (*len)++;`，这里的``*len``是一个指针，是一个指向``len``的指针，所以要用``*len``来取``len``的值，然后再加一
<!--ID: 1732188864683-->