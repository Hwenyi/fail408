---
publish: true
tags: 
aliases: 
finished: true
title: 题1
created: "2024-11-02 07:00"
updated: "2024-12-17 03:26"
---
## 题1
### 题目
> [!question]+
> 【2010】进程 ${P}_{0}$ 和 ${P}_{1}$ 的共享变量定义及其初值为:
> ```cpp
> boolean flag[2];
> int turn = 0;
> flag[0] = FALSE;
> flag[1] = FALSE;
> ```
> 若进程 ${P}_{0}$ 和 ${P}_{1}$ 访问临界资源的类C伪代码实现如下:
> ```cpp
> void P0() // 进程P0
> {
>     while(TRUE)
>     {
>         flag[0] = TRUE;
>         turn = 1;
>         while (flag[1] && (turn == 1));
>         // 临界区
>         flag[0] = FALSE;
>     }
> }
> 
> void P1() // 进程P1
> {
>     while(TRUE)
>     {
>         flag[1] = TRUE;
>         turn = 0;
>         while (flag[0] && (turn == 0));
>         // 临界区
>         flag[1] = FALSE;
>     }
> }
> ```
> 则并发 执行进程 ${p}_{0}$ 和 ${p}_{1}$ 时产生的情形是( )。 
> A. 不能保证进程互斥进入临界区, 会出现 “饥饿” 现象
> B. 不能保证进程互斥进入临界区, 不会出现 “饥饿” 现象
> C. 能保证进程互斥进入临界区, 会出现 “饥饿” 现象
> D. 能保证进程互斥进入临界区, 不会出现 “饥饿” 现象
### 分析
> [!NOTE]+
> 感觉没什么问题，和[[皮尔森算法]]的描述基本上是相同的，turn这个变量也是共用的，各自设置自己想要进入，但是又在turn上谦让另一个进程，最后自己用完了临界区，出来的时候也给自己置为了false，表示不想进入了
### 解
> [!done]+
> 【参考答案】D
> 【解析】题干描述的代码是Peterson算法的实例，既设置flag标志表明[[进程]]是否请求进入[[临界区]]，又设置共享变量turn规定进程进入临界区的顺序。在进入临界区前，进程P0检查另一个进程P1的标志flag[1]，又检查共享变量turn，可以保证两个进程同时希望进入临界区时，只有一个进程能进入临界区，同时由于先谦让对方的机制，不会出现饥饿现象，故本题选D。