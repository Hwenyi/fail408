---
publish: true
tags: []
aliases: 
finished: true
title: 题52
created: 2024-07-22 21:46
updated: 2024-11-04 18:03
---
## 题52
### 题目
【2010 统考真题】进程 ${P}_{0}$ 和进程 ${P}_{1}$ 的共享变量定义及其初值为:
```cpp
boolean flag[2];
int turn = 0;

flag[0] = false; flag[1] = false;
```
若进程 ${\mathrm{P}}_{0}$ 和进程 ${\mathrm{P}}_{1}$ 访问临界资源的类 $\mathrm{C}$ 代码实现如下: 
```cpp
void P0() //进程 P0
{
    while (true) {
        flag[0] = true;
        turn = 1;
        while (flag[1] && (turn == 1));
        // 临界区;
        flag[0] = false;
    }
}

void P1() //进程 P1
{
    while (true) {
        flag[1] = true;
        turn = 0;
        while (flag[0] && (turn == 0));
        // 临界区;
        flag[1] = false;
    }
}
```
则并发执行进程 ${\mathrm{P}}_{0}$ 和进程 ${\mathrm{P}}_{1}$ 时产生的情况是 ( ) 。
A. 不能保证进程互斥进入临界区, 会出现 “饥饿” 现象
B. 不能保证进程互斥进入临界区, 不会出现 “饥饿” 现象
C. 能保证进程互斥进入临界区, 会出现 “饥饿” 现象
D. 能保证进程互斥进入临界区, 不会出现 “饥饿” 现象
### 分析
定义了flag和trun，这是peterson算法
其中的flag表示谦让，表示想让谁上
其中的turn表示是谁的回合，轮到谁上
### 解
D
 - 这是 Peterson 算法的实际实现, 保证进入临界区的进程合理安全
- 该算法为了防止两个进程为进入临界区而无限期等待, 设置了变量 turn, 表示允许进入临界区的编号
    - 每个进程在**先设置自己的标志后**再设置 turn 标志, 允许另一个进程进入
    - 这时, 再**同时检测另一个进程状态标志**和**允许进入标志**, 就可保证当两个进程同时要求进入临界区时只允许一个进程进入临界区
    - 保存的是较晚的一次赋值, 因此较晚的进程等待, 较早的进程进入
    - 先到先入, 后到等待, 从而完成临界区访问的要求
- 其实这里可想象为两个人进门
    - 每个人进门前都会和对方客套一句“你走先”
    - 若进门时没别人, 就当和空气说句废话, 然后大步登门入室
    - 若两人同时进门, 就互相先请, 但各自只客套一次, 所以先客套的人请完对方, 就等着对方请自己, 然后光明正大地进门 

