---
publish: true
tags:
  - 操作系统
  - 进程
  - 互斥
  - 指令
  - 并发
  - TSL
  - 真题
  - 题目/选择题
  - 做错了
aliases: 
finished: true
title: 题55
created: 2024-07-22 21:46
updated: 2024-09-21 13:11
TARGET DECK: 刷题::25OS-王道::第 2 章 进程与线程::2.3 同步与互斥::题55
---
## 题55
### 题目
> [!question]+
> Q:【2016 统考真题】使用 TSL (Test and Set Lock) 指令实现进程互斥的伪代码如下所示
> ```cpp
> do {
>   ...
>   while (TSL(&lock));
>   critical section;
>   lock = FALSE;
>   ...
> } while(TRUE);
> ```
> 与该实现机制相关的叙述中, 正确的是 ( )。
> A. 退出临界区的进程负责唤醒阻塞态进程
> B. 等待进入临界区的进程不会主动放弃 CPU
> C. 上述伪代码满足 “让权等待” 的同步准则
> D. while (TSL(&lock)) 语句应在关中断状态下执行
### 分析
> [!NOTE]+
> A:让权等待是指在**进程请求资源时**,若**不能立即得到资源**,则应**主动释放 CPU**,让其他进程执行,从而**避免进程因等待资源而进入忙等待状态**
> 我觉得是选A，因为我觉得因为上锁的进程退出来的时候，执行了`lock=FALSE`，所以我认为这个解锁操作，让阻塞的进程可以进入临界区，就当做是把它唤醒了
> 事实上，唤醒这个词，指的是，进入就绪态，也就是等待cpu的使用权，这和临界区的资源似乎也是两个概念
### 解
> [!done]+
> B
> - 使用 TSL 指令实现进程互斥时, 并没有阻塞态进程
> - 等待**进入临界区的进程**一直**停留在执行 while(TSL(&lock))的循环**中
> 	- **不会主动放弃 CPU**
> 	- 一直处于运行态
> - **直到该进程的时间片用完**放弃处理机
> 	- 转为就绪态
> - 此时切换另一个就绪态进程占用处理机
> 	- **这不同于信号量机制实现的互斥**
> - 由此可知 A 和 C 错误
> - B 正确
> - TSL 指令本身就是原子操作
> 	- 不需要关中断来保证其不被打断
> - TSL 指令实现原子性的原理是, **执行 TSL 指令的 CPU 锁住内存总线**
> 	- 以禁止其他 CPU 在本指令结束之前访问内存
> - 此外, 假如 while(TSL(&lock))在关中断状态下执行
> - 若 TSL(&lock)一直为 true
> 	- 不再开中断
> 		- 则系统可能因此终止
> - 因此 D 错误
<!--ID: 1726714202315-->