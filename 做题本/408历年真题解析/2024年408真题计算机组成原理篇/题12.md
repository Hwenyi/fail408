---
publish: true
tags: 
aliases: 
finished: true
title: 题12
created: "2024-11-21 07:37"
updated: "2024-11-21 07:40"
---
## 题12
### 题目
> [!question]+
> C 语言代码如下。
> 
> ```cpp
> int i = 32777;
>  short si = i
>  int j = si;
> ```
> 
> 执行上述代码后，j 的值是
> 
> A. -32777
> 
> B. -32759
> 
> C. 32759
> 
> D. 32777
### 解
> [!done]+
> [[C语言]]中，int 为带符号整型，占 32 位，用补码表示，最高位为符号位，表示范围为 $-2^{31}\sim 2^{31}-1$ ，即 - 2,147,483,648~2,147,483,647。short 为带符号短整型，占 16 位，用补码表示，最高位为符号位，表示范围为 $-2^{15}\sim 2^{15}-1$ ，即 - 32,768~32,767。
> 
> 方法一：二进制计算
> 
> C 语言中，int 为带符号整型，占 32 位，用补码表示，最高位为符号位；short 为带符号短整型，占 16 位，用补码表示，最高位为符号位。
> 
> 第一行，将 32777 赋值给 i，i 的数据类型为 int， $32777=32768+8+1=2^{15}+2^{3}+2^0$ 转 32 位带符号补码为 0000 0000 0000 0000 1000 0000 0000 1001 B。
> 
> 第二行，将 i 的值赋值给 si，si 的数据类型为 short，int 转 short 采用高位截断，高 16 位丢失，保留低 16 位，因此 si 此时为 1000 0000 0000 1001 B。
> 
> 第三行，将 si 的值赋值给 j，j 的数据类型为 int，short 转 int 采用符号位高位扩展，si 符号位为 1，扩展高 16 位 1 到达 32 位，得到 j 此时为 1111 1111 1111 1111 1000 0000 0000 1001 B。补码转原码符号位不变，数值位取反，再加 1。[1111 1111 1111 1111 1000 0000 0000 1001] 补 = [1000 0000 0000 0000 0111 1111 1111 0111] 原 =-0111 1111 1111 1111 B+ 1000B= $-(2^{15}-1)+8$ = -32767+8=-32759。
> 
> 本题选 B。
> 
> 方法二：十进制计算
> 
> 第一行，将 32777 赋值给 i，i 的数据类型为 int，32777 在 int 表示范围内，i 此时为 32777。
> 
> 第二行，将 i 的值赋值给 si，si 的数据类型为 short，被赋值 32777，32777>32767，超出 short 表示范围，表现为上溢，需要进行负向偏移一个 short 的模数（等于其表示范围大小） $2^{16}=65536$ ，得到 32777-65536=-32759，因此 si 此时为 -32759。
> 
> 第三行，将 si 的值赋值给 j，j 的数据类型为 int，-32759 在 int 表示范围内，因此 j 此时为 - 32759。
> 
> 本题选 B。
> 
> **_拓展_**
> 
> ![](https://pic2.zhimg.com/v2-8f348201ad84c23a7b80363fd28efb75_1440w.jpg)
> 
> 这里补充下整型表示方法的本质。如果学习过数论的同学，就会明白环即是取模，或者可将取模运算理解是环上的运算。整型可以表示所有的整数，犹如时钟可以表示无限的时间。整型的模数是一个周期，犹如时钟 12 小时是一个周期。