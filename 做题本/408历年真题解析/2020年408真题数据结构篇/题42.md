---
publish: true
tags: 
aliases: 
finished: true
title: 题42
created: "2024-11-21 07:26"
updated: "2024-11-21 07:40"
---
## 题42
### 题目
> [!question]+
> （10 分）
> 
> 若任一个字符的编码都不是其它字符编码的前缀，则称这种编码具有前缀特性。现有某字符集（字符个数≥2）的不等长编码，每个字符的编码均为二进制的 0、1 序列，最长为 L 位，且具有前缀特性。请回答下列问题：
> 
> ⑴ 哪种数据结构适宜保存上述具有前缀特性的不等长编码？
> 
> ⑵ 基于你所设计的数据结构，简述从 0/1 串到字符串的译码过程。
> 
> ⑶ 简述判定某字符集的不等长编码是否具有前缀特性的过程。
### 解
> [!done]+
> ⑴ 题目要求：“若任一个字符的编码都不是其它字符编码的前缀，则称这种编码具有前缀特性。”
> 
> 看到这里马上联想到前缀无关编码和[[哈夫曼树-aw|哈夫曼树]]，或者前缀无关编码对应的二叉树。哈夫曼树是某一最优前缀无关编码对应的二叉树。
> 
> 注：《数据结构（C 语言版）》和《算法导论》第三版中称为前缀编码 (prefix codes)，《算法导论》第四版和《计算理论导论》第三版中都已经改成前缀无关编码(prefix-free codes)，个人认为称为前缀无关编码更加准确，充分表达出定义中“不是” 的含义。
> 
> 这里可以构造一棵度为 2 的哈夫曼树，字符保存在叶结点中，左指针路径上标 0，右指针路径上标 1，从根结点到叶结点路径上的 0 或 1 组成的串即为该字符的前缀无关编码。
> 
> 字符保存在叶结点中，左指针路径上标 0，右指针路径上标 1，从根结点到叶结点路径上的 0 或 1 组成的串即为该字符的前缀无关编码。
> 
> ![](https://pica.zhimg.com/v2-5b44539b1121d073611306138a57664e_r.jpg)
> 
> ⑵ 按序遍历 0/1 串，对应从[[哈夫曼树-aw|哈夫曼树]]中找一条从根结点开始的路径，到叶结点终止，输出叶结点对应的字符。然后重新从根结点开始重复这个过程。
> 
> ⑶ 构造[[二叉树]]，由于任意一个字符编码不是另一个字符编码的前缀，字符信息只能存在叶结点中。如果构造成功，那么某字符集的不等长编码具有前缀特性。
> 
> 注：参考《算法导论》相关章节如下：
> 
> - [算法导论（第四版）第十五章：贪心算法　第三节：哈夫曼编码](https://zhuanlan.zhihu.com/p/574351593)
> 
> 拓展：如果不考虑前缀冲突，可以将前缀编码对应的二叉树拓展为前缀树（也称为[[字典树 -数组实现- 理解|字典树]]，英文名 Trie，是英文单词 retrieve 的截取，retrieve 意为检索）。
> 
> 字典树：又称单词查找树，Trie 树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。
> 
> 字典树可以用来保存英文单词等更加复杂的编码，比如力扣中 [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)。