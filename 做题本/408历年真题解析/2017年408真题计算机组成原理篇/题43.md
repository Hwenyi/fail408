---
publish: true
tags: 
aliases: 
finished: true
title: 题43
created: "2024-11-21 07:17"
updated: "2024-11-21 07:40"
---
## 题43
### 题目
> [!question]+
> （13 分）
> 
> 已知 $f(n)=\sum_{i=0}^n2^i=2^{n+1}-1=\overbrace{11\cdots 1}^{n+1\text{位}}{\rm B}$ ，计算 f(n) 的 C 语言函数 f1 如下：
> 
> ```cpp
> int f1(unsigned n) { 
>     int sum=1, power=1;
>     for (unsigned i=0; i<=n-1; i++) { 
>         power*=2;
>         sum+=power;
>     }
>     return sum;
> }
> ```
> 
> 将 f1 中的 int 都改为 float，可得到计算 f(n) 的另一个函数 f2。假设 unsigned 和 int 型数据都占 32 位，float 采用 IEEE754 单精度标准。请回答下列问题。
> 
> (1) 当 n=0 时，f1 会出现死循环，为什么？若将 f1 中的变量 i 和 n 都定义为 int 型，则 f1 是否还会出现死循环？为什么？
> 
> (2) f1(23) 和 f2(23) 的返回值是否相等？机器数各是什么（用十六进制表示）？
> 
> (3) f1(24) 和 f2(24) 的返回值分别为 33554431 和 33554432.0，为什么不相等？
> 
> (4) f(31)= $2^{32}-1$ ，而 f1(31) 的返回值却为 - 1，为什么？若使 f1(n) 的返回值与 f(n) 相等，则最大的 n 是多少？
> 
> (5) f2(127) 的机器数为 7F80 0000H，对应的值是什么？若使 f2(n) 的结果不溢出，则最大的 n 是多少？若使 f2(n) 的结果精确（无舍入），则最大的 n 是多少？
### 解
> [!done]+
> 虽然 f1 和 f2 都是计算的是 $f(n)=2^{n+1}-1$ ，但是由于输入和输出数据类型的限制，实际输出结果可能有出入。
> 
> (1) 由于 i 和 n 是 unsigned 型，因此 “i <= n-1” 是无符号数比较。n=0 时，n-1 的机器数为全 1，值是 $2^{32}-1$ ，为 unisgned 型可表示的最大数，条件 “i <= n-1” 恒为真，因此出现死循环。
> 
> 若将 i 和 n 改为 int 类型，则不会出现死循环。因为 “i <= n-1” 是有符号数比较。n=0 时，n-1 的值是 - 1，当 i = 0 时条件 “i <= n-1” 为假，此时退出 for 循环。
> 
> (2) f1(23) 与 f2(23) 的返回值相等。 $f(23)=\overbrace{11\cdots 1}^{24\text{位}}{\rm B}$ 。f1(23) 为 int 类型，int 占 32 位，没有溢出。f2(23) 为 float 类型，float 采用 IEEE754 单精度[[浮点数]]标准，float 有 1 个符号位，8 个指数位，23 个尾数位，**考虑小数点前面省略的 1，float 有 24 个有效数值位**。阶码为 23+127=150=10010110B。所以两者返回值相等。
> 
> f1(23) 为 int 类型，机器数是 0000 0000 1111 1111 1111 1111 1111 1111B = 00FFFFFFH。
> 
> f2(23) 为 float 类型，float 采用 IEEE754 单精度标准，机器数是 $\underbrace{0}_S \underbrace{10010110}_E \underbrace{111 1111 1111 1111 1111 1111}_M {\rm B}$ =4B7FFFFFH。
> 
> (3) 当 n=24 时， $f(24)=\overbrace{11\cdots 1}^{25\text{位}}{\rm B}$ 。f1(23) 为 int 类型，int 占 32 位，没有溢出。f2(23) 为 float 类型，float 采用 IEEE754 单精度[[浮点数]]标准，float 有 1 个符号位，8 个指数位，23 个尾数位，考虑小数点前面省略的 1，**float 有 24 个有效数值位。不满足 25 个有效数值位的要求**，这里需要进行舍入，**按 0 舍 1 入**，f2(24)= $2^{25}$ =33554432.0，比 f1(24)= $2^{25}-1$ =33554431 大，即 f1(24) 和 f2(24) 返回值不相等。
> 
> (4) f(31)= $2^{32}-1$ ，int 表示范围为 $-2^{31}\sim 2^{31}-1$ ，溢出，f1(31) 的二进制形式是 32 个 1，C 语言整型用补码表示，得到 f1(31) 的返回值为 - 1。因为 $f(n)=\overbrace{11\cdots 1}^{n+1\text{位}}{\rm B}$ 且 int 型最大可表示数是符号位为 0 后面 31 个数值位全为 1，即 n+1=31，解得 n=30，所以使 f1(n) 的返回值与 f(n) 相等的最大 n 值是 30。
> 
> (5) 7F80 0000H= $\underbrace{0}_S \underbrace{11111111}_E \underbrace{000 0000 0000 0000 0000 0000}_M {\rm B}$ ，阶码位全 1，尾数位全 0，表示无穷大，符号位为 0，表示正无穷大，即 $+\infty$ 。
> 
> 当 n=127 时， $f(127)=\overbrace{11\cdots 1}^{128\text{位}}{\rm B}$ 。表示为[[浮点数]] $\underbrace{0}_S \underbrace{11111110}_E \underbrace{111 1111 1111 1111 1111 1111}_M (\overbrace{11\cdots 1}^{104\text{位}}){\rm B}$ ，括号内为需要舍入的部分，**按 0 舍 1 入进行舍入后需要右规**，阶码加 1，得到 $\underbrace{0}_S \underbrace{11111111}_E \underbrace{000 0000 0000 0000 0000 0000}_M {\rm B}$ ，该浮点数表示 $+\infty$ ，溢出。
> 
> 当 n=126 时， $f(126)=\overbrace{11\cdots 1}^{127\text{位}}{\rm B}$ 。表示为浮点数 $\underbrace{0}_S \underbrace{11111101}_E \underbrace{111 1111 1111 1111 1111 1111}_M (\overbrace{11\cdots 1}^{103\text{位}}){\rm B}$ ，括号内为需要舍入的部分，按 0 舍 1 入进行舍入后需要右规，阶码加 1，得到 $\underbrace{0}_S \underbrace{11111110}_E \underbrace{000 0000 0000 0000 0000 0000}_M {\rm B}$ ，阶码 11111110B 达到 IEEE754 单精度格式表示的最大阶码。
> 
> 综上，若使 f2(n) 的结果不溢出，则最大的 n 是 126。
> 
> 当 n = 24 时根据 (1) 的结果，f2(24)需要舍入。
> 
> 当 n = 23 时， $f(23)=\overbrace{11\cdots 1}^{24\text{位}}{\rm B}$ 。f2(23) 为 float 类型，float 采用 IEEE754 单精度标准，float 有 1 个符号位，8 个指数位，23 个尾数位，考虑小数点前面省略的 1，float 有 24 个有效数值位。所以不需舍入，结果精确。
> 
> 综上，若使 f2(n) 的结果精确（无舍入），则最大的 n 是 23。