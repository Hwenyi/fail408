---
publish: true
tags: 
aliases: 
finished: true
title: 题43
created: "2024-11-21 07:26"
updated: "2024-11-21 07:40"
---
## 题43
### 题目
> [!question]+
> （15 分）
> 
> 假定计算机 M 字长为 16 位，按字节编址，连接 CPU 和主存的系统总线中地址线为 20 位、数据线为 8 位，采用 16 位定长指令字，指令格式及其说明如下：
> 
> ![](https://picx.zhimg.com/v2-5e075d388a49ede8ea00acb67ef7eafd_r.jpg)
> 
> 其中，op1~op3 为操作码，rs、rt 和 rd 为通用寄存器编号，R[r] 表示寄存器 r 的内容，imm 为立即数，target 为转移目标的形式地址。请回答下列问题。
> 
> (1) ALU 的宽度是多少位？可寻址主存空间大小为多少字节？指令寄存器、主存地址寄存器（MAR）和主存数据寄存器（MDR）分别应有多少位？
> 
> (2) R 型格式最多可定义多少种操作？I 型和 J 型格式总共最多可定义多少种操作？通用寄存器最多有多少个？
> 
> (3) 假定 op1 为 0010 和 0011 时，分别表示带符号整数减法和带符号整数乘法指令，则指令 01B2H 的功能是什么（参考上述指令功能说明的格式进行描述）？若 1、2、3 号通用寄存器当前内容分别为 B052H、0008H、0020H，则分别执行指令 01B2H 和 01B3H 后，3 号通用寄存器内容各是什么？各自结果是否溢出？
> 
> (4) 若采用 I 型格式的访存指令中 imm（偏移量）为带符号整数，则地址计算时应对 imm 进行零扩展还是符号扩展？
> 
> (5) 无条件转移指令可以采用上述哪种指令格式？
### 解
> [!done]+
> (1) 第一问。ALU 的宽度为 16 位。ALU 的宽度是指它能够处理的位数。一般等于字长，因为计算机 M 字长为 16 位，所以 ALU 的宽度为 16 位。
> 
> 第二问。可寻址主存空间大小为 $2^{20}$ 字节（或 1MB）。地址线 20 位，可表示地址数为 $2^{20}$ ，计算机按字节编址，所以主存空间大小为 $\rm 2^{20}\times1B=2^{20}B=1MB$ 。
> 
> 第三问。指令寄存器、主存地址寄存器（MAR）和主存数据寄存器（MDR）各有 16 位、20 位和 8 位。指令寄存器用于存储指令，指令字长 16 位，所以指令寄存器有 16 位。主存地址寄存器（MAR）位数等于地址线位数，地址线为 20 位，所以 MAR 有 20 位。主存数据寄存器（MDR）位数等于数据线位数，数据线为 8 位，所以 MDR 有 8 位。
> 
> (2) 第一问。R 型格式最多有 16 种操作。R 型格式操作码 op1 占 4 位，最多有 $2^4=16$ 种操作。
> 
> 第二问。I 型和 J 型格式总共最多有 63 种操作。I 型格式操作码 op2 和 J 型格式操作码 op3 都占高 6 位，但其中 00000 操作码已经被 R 型占用，所以 I 型和 J 型格式总共最多有 $2^6-1=63$ 63 种操作。
> 
> 第三问。通月寄存器最多有 4 个。rs、rt 和 rd 为通用寄存器编号，都占 2 位，所以通月寄存器最多有 $2^2=4$ 个。
> 
> (3) 指令 01B2H = 0000 0001 1011 0010B，高 6 位为 000000，为 R 型格式指令，所以 $\rm 000000\underbrace{01}_{rs}\underbrace{10}_{rt}\underbrace{11}_{rd} \underbrace{0010}_{op1}$ ，表示 R[rd] $\leftarrow$ R[rs] op1 R[rt]，op1=0010 表示带符号整数减法指令，rs 为 1 号寄存器，内容为 B052H，rt 为 2 号寄存器，内容为 0008H，rd 为 3 号寄存器，内容为 0020H，即其功能为 R[3]$\leftarrow$R[1]-R[2]。执行指令 01B2H 后，R[3]=B052H-0008H=B04AH，被减数 B052H 和减数 0008H 均视为无符号数，显然 B052H 够减 0008H，该减法没有发生借位，结果不溢出。
> 
> 指令 01B3H = 0000 0001 1010 1011B，为 R 型格式指令，所以 $\rm000000\underbrace{01}_{rs}\underbrace{10}_{rt}\underbrace{11}_{rd} \underbrace{0011}_{op1}$ ，表示 R[rd] $\leftarrow$ R[rs] op1 R[rt]，op1=0011 表示带符号整数乘法指令，rs 为 1 号寄存器，内容为 B052H，rt 为 2 号寄存器，内容为 0008H，rd 为 3 号寄存器，内容为 0020H，即其功能为 R[3]$\leftarrow$R[1]×R[2]。执行指令 01B3H 后，R[3]=B052H×0008H。关于该乘法的计算，有如下两种方法：
> 
> **方法一：转十进制后用十进制乘法运算**
> 
> 将二进制乘法转化为十进制乘法计算，R[3]=B052H×0008H=-20398×8=-163184，16 位有符号整型的表示范围为 - 32768~32767，-163184 超出其表示范围，结果溢出。
> 
> **方法二：二进制补码乘法运算**
> 
> 计算机中带符号整数一般使用补码表示，带符号整数乘使用的是补码乘法，其核心算法为补码比较法（Booth 算法）。Booth 算法对乘数从低位开始判断，根据两个数据位的情况决定进行加法、减法还是仅仅移位操作。判断的两个数据位为当前位及其右边的位（初始时需要增加一个辅助位 0），移位操作是向右移动。其中 Booth 算法在操作时，需要遵循一个操作表：
> 
> $\begin{array}{|c|c|c|}\hline Y_n\text{（高位）}&Y_{n+1}\text{（低位）}&\text{操作}\\\hline 0&0&+0\text{，右移一位}\\\hline 0&1&+[X]_{\text{补}}\text{，右移一位}\\\hline 1&0&+[-X]_{\text{补}}\text{，右移一位}\\\hline 1&1&+0\text{，右移一位}\\\hline \end{array}$
> 
> 具体步骤如下：
> 
> 1. 被乘数_X_与乘数_Y_均以补码的形式参加乘法运算，运算结果是积的补码。
> 2. 部分积和被乘数_X_采用双符号位，乘数_Y_采用单符号位。
> 3. 初始部分积为 0。运算前，在乘数_Y_的补码末位添加一位附加位 $Y_{n+1}$ ，初始值为 0。
> 4. 根据 $Y_nY_{n+1}$ 的值，按照上表进行累加右移操作，右移时遵循补码的移位规则。
> 5. 累加 n+1 次，右移 n 次，最后一次不右移。
> 
> ![](https://picx.zhimg.com/v2-5c39e895454a1400b4ce6fd4dcf2423f_r.jpg)
> 
> 模拟上述过程得到 R[3] = B052H×0008H = 1111 1111 1111 1101 1000 0010 1001 0000B，因为寄存器只能存储 16 位有符号整型，所以低 15 位为数值位，高 17 位为符号位和符号扩展位，高 17 位非全 1，结果溢出。
> 
> **方法三：用算术左移运算模拟乘法运算**
> 
> R[3]=B052H×0008H 中乘数 0008H= $2^3$ ，经过编译器优化后，乘法运算可以转化为算术左移运算，这里在单符号位基础上扩展 16 位符号扩展位，用 <<表示左移运算，则 R[3] = B052H×0008H = B052H<<3 = 1011 0000 0101 0010B<<3 = 1111 1111 1111 1111 1011 0000 0101 0010B<<3 = 1111 1111 1111 1101 1000 0010 1001 0000B，因为寄存器只能存储 16 位有符号整型，所以低 15 位为数值位，高 17 位为双符号位和符号扩展位，高 17 位非全 1，结果溢出。
> 
> (4) 因为 imm（偏移量）为带符号整数，所以应对 imm 进行符号扩展。
> 
> (5) 无条件转移指令可以采用 J 型格式。因为 J 型格式功能为 target→PC 的低 10 位，无条件转移指令需要更新 PC 内容，把 target 送到 PC 的低 10 位后，PC 内容为目标指令地址。