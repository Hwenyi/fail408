---
publish: true
tags: 
aliases: 
finished: true
title: 题42
created: "2024-11-21 06:41"
updated: "2024-11-21 07:40"
---
## 题42
### 题目
> [!question]+
> （15 分）
> 
> 一个长度为 $L(L\ge1)$ 的升序序列 $S$ ，处在第 $\lceil L/2 \rceil$ 个位置的数称为 $S$ 的中位数。例如，若序列 $S_1=\langle11,13,15,17,19 \rangle$ ，则 $S_1$ 的中位数是 $15$ 。两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若序列 $S_2=\langle2,4,6,8,20 \rangle$ ，则 $S_1$ 和 $S_2$ 的中位数是 $11$ 。现有两个等长的升序序列 $A$ 和 $B$ ，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列 $A$ 和 $B$ 的中位数。要求：
> 
> ⑴ 给出算法的基本设计思想。
> 
> ⑵ 根据设计思想，采用 C 或 C++ 或 Java 语言描述，关键之处给出注释。
> 
> ⑶ 说明你所设计算法的时间复杂度和空间复杂度。
### 解
> [!done]+
> 本人按照算法的时间复杂度由高到低整理出了六种方法，详见 [408 史上最难算法题：两个升序数组的中位数](https://zhuanlan.zhihu.com/p/554883795)。
> 
> 这道题最优解的思路非常巧妙，深入考查了**折半查找（二分查找）思想，同学们可以尝试理解。
> 
> 本题为 408 史上最难算法题，力扣困难难度的算法题，408 算法题出困难难度的概率较低，理论上 8~10 年出现一次，同学们平时还是主要把简单和中等难度的算法题掌握好即可。
> 
> 评：王道给出的参考答案中代码部分出现错误，错误出现在最后一个 else 分支，其中两行代码均错误。
> 
> 错误代码为：
> 
> ```cpp
> else { // 若元素个数为偶数
>     d1 = m1 + 1;  // 舍弃A中间点以后的部分且保留中点
>     s2 = m2;  // 舍弃B中间点及中间点以前的部分
> }
> ```
> 
> 正确代码为：
> 
> ```cpp
> else { // 若元素个数为偶数
>     d1 = m1;  // 舍弃A中间点以后的部分且保留中点
>     s2 = m2 + 1;  // 舍弃B中间点及中间点以前的部分
> }
> ```
> 
> 完整校正如下：
> 
> ```cpp
> int Search(int A[], int B[], int n) { // n即为序列长度L
>     int s1 = 0, d1 = n - 1, m1, s2 = 0, d2 = n - 1, m2;
>     while(s1 != d1 || s2 != d2) {
>         m1 = (s1 + d1) / 2;
>         m2 = (s2 + d2) / 2;
>         if (A[m1] == B[m2]) {
>              return A[m1];
>         } else if (A[m1] < B[m2]) { 
>             // 分别考虑奇数和偶数，保持两个子数组元素个数相等
>             if ((s1 + d1) % 2 == 0) { // 若元素个数为奇数
>                  s1 = m1;  // 舍弃A中间点以前的部分且保留中点
>                  d2 = m2;  // 舍弃B中间点以后的部分且保留中点
>             } else { // 若元素个数为偶数
>                  s1 = m1 + 1;  // 舍弃A中间点及中间点以前的部分
>                  d2 = m2;  // 舍弃B中间点以后的部分且保留中点
>             }
>         } else {
>             // 分别考虑奇数和偶数，保持两个子数组元素个数相等
>             if ((s1 + d1) % 2 == 0) { // 若元素个数为奇数
>                  d1 = m1;  // 舍弃A中间点以后的部分且保留中点
>                  s2 = m2;  // 舍弃B中间点以前的部分且保留中点
>             } else { // 若元素个数为偶数
>                  d1 = m1;  // 舍弃A中间点以后的部分且保留中点
>                  s2 = m2 + 1;  // 舍弃B中间点及中间点以前的部分
>             }
>         }
>     }
>     return A[s1] < B[s2] ? A[s1] : B[s2];
> }
> ```
> 
> 写代码应该非常严谨，王道虎头蛇尾的做法不值得学习。
> 
> 注：《2024 年计算机专业基础综合考试历年真题解析》此处已勘误。