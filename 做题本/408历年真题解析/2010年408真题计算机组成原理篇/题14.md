---
publish: true
tags: 
aliases: 
finished: true
title: 题14
created: "2024-11-21 06:40"
updated: "2024-11-21 07:40"
---
## 题14
### 题目
> [!question]+
> 假定变量 i、f 和 d 的数据类型分别为 int、float、double（int 用补码表示，float 和 double 分别用 IEEE754 单精度和双精度浮点数据格式表示），已知 i=785，f=1.5678e3，d=1.5e100，若在 32 位机器中执行下列关系表达式，则结果为真的是（ ）。
> 
> Ⅰ. `i==(int)(float)i`
> 
> Ⅱ. `f==(float)(int)f`
> 
> Ⅲ. `f=(float)(double)f`
> 
> Ⅳ.`(d+f)-d==f`
> 
> A. 仅 Ⅰ 和 Ⅱ
> 
> B. 仅 Ⅰ 和 Ⅲ
> 
> C. 仅 Ⅱ 和 Ⅲ
> 
> D. 仅 Ⅲ 和 Ⅳ
### 解
> [!done]+
> 在一般的计算机中，int 的表示范围为 - 2147483648~2147483647，float 表示范围约为 - 3.4e38～3.4e38，double 表示范围约为 - 1.79e308 ~ +1.79e308。这里 $a\text{e}b$ 表示 $a\times 10^b$ 。
> 
> IEEE754 浮点数的格式如下：
> 
> 类型短浮点数长[[浮点数]]数符阶码尾数数值总位数
> $\begin{array}{|c|}\hline \text{类型}&\text{数符}&\text{阶码}&\text{尾数数值}&\text{总位数}\\\hline \text{短浮点数}&1&8&23&32\\\hline \text{长浮点数}&1&11&52&64\\ \hline\end{array}$
> 
> 在 C 语言中，短[[浮点数]]记作 float，长[[浮点数]]记作 double。
> 
> 对于 I，i 为 int，因为 float 二进制[[浮点数]]数值最多能表示 24 位（23 个小数位和 1 位省略的整数位）有效数值位，int 转 float 当有效数值位**超出 24 位时可能会出现精度丢失**，i=785=1100010001B，所以 (float)i 这一步不会改变 i 的值，float 转 int 会出现小数位丢失，由于 785 为整数，小数位全为 0，所以 (int)(float)i 这一步也不会改变 i 的值。命题 I 化简化简后为 785 == 785。I 为真。
> 
> 对于 II，f=1.5678e3=1567.8，float 转 int 会出现小数位丢失，(int)f 转变为 1567，int 转 float 当尾数超出 24 位时可能会有精度丢失，1567=11000011111B，其二进制表示有 11 个有效数值位，所以 (float)(int)f 这一步不会改变 (int)f 的值。命题 II 化简后为 1.5678e3 == 1567。II 为假。
> 
> 对于 III，float 转 double 不会出现影响，(double)f 这一步不会改变 f 的值，由于 float 能够容纳 1.5e100，所以 (float)(double)f 这一步也不会改变 (double)f 的值，综上，两步类型转化后不会改变 f 的值。命题 III 化简化简后有 1.5678e3 == 1.5678e3。III 为真。
> 
> 对于 IV，首先考虑加法，d+f，d 和 f 类型不同，需要统一类型，低精度类型转为高精度类型，这里 f 隐式转为 double 类型，转化后 f=1.5678e3，d+f 等价于 d+(double)f，然后执行浮点数加法运算，首先需要进行对阶，小阶向大阶对齐，假设对阶后 f 不变，为 ($1.5678\times10^{-97}$)e100，因为 double 二进制[[浮点数]]数值最多最多能表示 53 位（52 个小数位和 1 位省略的整数位）， $2^{-52}\approx 2.22\times 10^{-16}$ ，（关于 $2^{-52}$ 的计算，可以使用 $2^{10}\approx 10^3$ 这个近似，得到 $2^{-52}=2^{-2}(2^{-10})^5\approx2^{-2}(10^{-3})^5=2.5\times10^{-16}$ 。）double 尾数转换为十进制精确到小数点后 16 位，显然无法精确到小数点后 97 位，所以 f 对阶后精度丢失，变为 0e100，d+f 结果为 1.5e100，类型为 double。然后考虑减法，(d+f) 和 d 的类型相同，均为 double，直接进行浮点数运算，(d+f)-d 计算结果为 0。命题 IV 化简后为 0 == 1.5678e3。IV 为假。
> 
> 综上，I 和 III 为真。
> 
> 本题选 B。
> 
> **举一反三**
> 
> 假定变量 i、f 和 d 的数据类型分别为 int、float、double（int 用补码表示，float 和 double 分别用 IEEE754 单精度和双精度浮点数据格式表示），已知 i=1e9+7，f=1.567e3，d=1.5e6，若在 32 位机器中执行下列关系表达式，则结果为真的是（ ）。
> 
> Ⅰ. `i==(int)(float)i`
> 
> Ⅱ. `f==(float)(int)f`
> 
> Ⅲ. `f=(float)(double)f`
> 
> Ⅳ. `(d+f)-d==f`
> 
> 参考答案：II、III 和 IV。