---
publish: true
tags: 
aliases: 
finished: true
title: 题44
created: "2024-11-21 06:40"
updated: "2024-11-21 07:40"
---
## 题44
### 题目
> [!question]+
> （12 分）
> 
> 某计算机的主存地址空间大小为 256MB，按字节编址，指令 Cache 和数据 Cache 分离，均有 8 个 Cache 行，每个 Cache 行大小为 64B，数据 Cache 采用直接映射方式。现有两个功能相同的程序 A 和 B，其伪代码如下所示：
> 
> 程序 A：
> 
> ```cpp
> int a[256][256]
> ...
> int sum_array1()
> {
>  int i, j, sum=0;
>  for (i=0; i<256; i++)
>  for (j=0; j<256; j++)
>  sum += a[i][j]
>  return sum;
> }
> ```
> 
> 程序 B：
> 
> ```cpp
> int a[256][256]
> ...
> int sum_array1()
> {
>  int i, j, sum=0;
>  for (j=0; j<256; j++)
>  for (i=0; i<256; i++)
>  sum += a[i][j]
>  return sum;
> }
> ```
> 
> 假定 int 类型数据用 32 位补码表示，程序编译时 i、j、sum 均分配在寄存器中，数组 a 按行优先方式存放，首地址 320（十进制数）。请回答下列问题，要求说明理由或给出计算过程。
> 
> (1) 若不考虑用于 Cache 一致性维护和替换算法的控制位, 则数据 Cache 的总容量为多少？
> 
> (2) 数组数据 `a[0][31]` 和 `a[1][1]` 各自所在的主存块对应的 Cache 行号分别是多少（Cache 行号从 0 开始）？
> 
> (3) 程序 A 和 B 的数据访问命中率各是多少？哪个程序的执行时间更短？
### 解
> [!done]+
> (1) 每个 Cache 行对应一个标记项，标记项包括有效位、脏位、替换控制位以及主存字块标记位。由主存空间大小为 256MB，按字节编址， $\rm 256M = 2^{28}$ ，地址总长度为 28 位，每个 Cache 行大小为 64B，块内地址为 log64=6 位，有 8 个 Cache 行，Cache 行号为 log8=3 位，主存字块标记位数为 28-6-3=19 位，不考虑一致性维护和替换算法的控制位，还需一位有效位，19+1=20 标记位，20bit=20/8B，数据 Cache 共有 8 行，可计算 Cache 的总容量：
> 
> Cache 的总容量 = 行数 ×(每行标记位大小 + 每行 Cache 块大小)=8×(64+20/8)B=532B。
> 
> (2) 本题代码为 C 语言代码，在 C 语言中，二维数组按行优先方式存放。
> 
> 注：大多数高级语言如 C、Java、Python 等中二维数组按行优先方式存放，少数高级语言如 Fortran 等中二维数组按列优先方式存放。
> 
> 数组首地址为 320，数组元素占 4 个字节。
> 
> `a[256][256]` 表示数组有 256 行，每行有 256 个元素。
> 
> Cache 采用直接映射方式，即**计算行号的散列函数为除留余数法**。
> 
> 方法一：除法运算和模运算
> 
> `a[0][31]` 所在的主存块对应的 Cache 行号为 $\lfloor \rm(320B+(256\times0+31)\times 4B)/64B\rfloor\text{ mod }8=6$ 。
> 
> `a[1][1]` 所在的主存块对应的 Cache 行号为 $\lfloor \rm(320B+(256\times1+1)\times 4B)/64B\rfloor\text{ mod }8=5$ 。
> 
> 方法二：位运算（二进制串分割）
> 
> `a[0][31]` 所在地址为 $\rm 320+(256\times0+31)\times 4 =444=110111100B=\underbrace{0000000000000000000}_{\text{主存字块标记}}\,\underbrace{110}_{\text{行号}}\, \underbrace{111100}_{\text{块内地址}}B$ ，行号为 110B=6。
> 
> `a[1][1]` 所在地址为 $\rm 320+(256\times1+1)\times 4 =1348=10101000100B=\underbrace{0000000000000000010}_{\text{主存字块标记}}\,\underbrace{101}_{\text{行号}} \,\underbrace{000100}_{\text{块内地址}}B$ ，行号为 101B=5。
> 
> 对于 Cache 映射方式的考题，推荐使用位运算（二进制串分割）处理。
> 
> (3) 第一问。
> 
> 数组 a 按行存放，程序 A 按行存取。每个字块中存放 16 个 int 型数据，除访问的第一个不命中 ，随后的 15 个全都命中，我们模拟程序执行，第一个需访问的元素为 `a[0][0]`，初始 Cache 为空，Cache 缺失，`a[0][0]` 所在地址为 $\rm 320+(256\times0+0)\times 4=320=\underbrace{0000000000000000000}_{\text{主存字块标记}}\,\underbrace{101}_{\text{行号}} \,\underbrace{000000}_{\text{块内地址}}B$ ，映射到行 5，接下来访问 `a[0][0]`，第二个访问需访问的元素为 `a[0][1]`，`a[0][1]` 所在地址为 $\rm 320+(256\times0+1)\times 4=321=\underbrace{0000000000000000000}_{\text{主存字块标记}}\,\underbrace{101}_{\text{行号}} \,\underbrace{000001}_{\text{块内地址}}B$ ，映射到行 5，且与已加载的块主存字块标记相同，Cache 命中，依次类推，`a[0][2]`, `a[0][3]`, ... , `a[0][15]` 也都命中。每访问 16 个元素 Cache 缺失 1 次。
> 
> 又因为 $256\text{ mod }16 =0$ ，数组大小为字块大小的整数倍，访问全部字块都符合这一规律，程序 A 的命中率为 15/16=93.75%。
> 
> 数组 a 按行存放，程序 B 按列存取，Cache 总容量为 64B×8=512B，数组 a 一行的大小为 1KB，正好是 Cache 容量的 2 倍。Cache 采用直接映射方式，即计算行号的散列函数为除留余数法。不同行的同一列数组元素地址同余，所以不同行的同一列数组元素使用的是同一个 Cache 单元，故逐列访问每个数据时，都会将之前的字块置换出，也即每次访问都不会命中，命中率为 0。
> 
> 我们模拟程序执行，第一个需访问的元素为 `a[0][0]`，初始 Cache 为空，Cache 缺失，`a[0][0]` 所在地址为 $\rm 320+(256\times0+0)\times 4=320=\underbrace{0000000000000000000}_{\text{主存字块标记}}\,\underbrace{101}_{\text{行号}} \,\underbrace{000000}_{\text{块内地址}}B$ ，映射到行 5，第二个访问需访问的元素为 `a[1][0]`，`a[1][0]` 所在地址为 $\rm 320+(256\times1+0)\times 4=1344=\underbrace{0000000000000000010}_{\text{主存字块标记}}\,\underbrace{101}_{\text{行号}} \,\underbrace{000000}_{\text{块内地址}}B$ ，映射到行 5，与已加载的块主存字块标记不同，Cache 缺失，置换 Cache 块。依次类推，对于任意 `a[i][j]` 全部 Cache 缺失，命中率为 0。
> 
> 综上，程序 A 数据访问命中率为 93.75%；程序 B 数据访问命中率为 0。
> 
> 第二问。根据上述计算出的命中率，可知程序 A 数据访问命中率高于 B，程序 B 每次取数都要访问主存，所以程序 A 的执行比程序 B 快得多，即程序 A 的执行时间更短。