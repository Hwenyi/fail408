---
publish: true
tags: 
aliases: 
finished: true
title: 题43
created: "2024-11-21 07:26"
updated: "2024-11-21 07:40"
---
## 题43
### 题目
> [!question]+
> （13 分）
> 
> 有实现 x×y 的两个 C 语言函数如下：
> 
> ```cpp
> unsigned umul (unsigned x, unsigned y) { return x*y; }
> int imul (int x, int y) { return x * y; }
> ```
> 
> 假定某计算机 M 中 ALU 只能进行加减运算和逻辑运算。请回答下列问题。
> 
> (1) 若 M 的指令系统中没有乘法指令，但有加法、减法和移位等指令，则在 M 上也能实现上述两个函数中的乘法运算，为什么？
> 
> (2) 若 M 的指令系统中有乘法指令，则基于 ALU、移位器、寄存器以及相应控制逻辑实现乘法指令时，控制逻辑的作用是什么？
> 
> (3) 针对以下三种情况：①没有乘法指令；②有使用 ALU 和移位器实现的乘法指令；③有使用阵列乘法器实现的乘法指令，函数 umul() 在哪种情况下执行时间最长？哪种情况下执行的时间最短？说明理由。
> 
> (4) n 位整数乘法指令可保存 2n 位乘积，当仅取低 n 位作为乘积时，其结果可能会发生溢出。当 n=32、x= $2^{31}-1$ 、y=2 时，带符号整数乘法指令和无符号整数乘法指令得到的 x×y 的 2n 位乘积分别是什么（用十六进制表示）？此时函数 umul() 和 imul() 的返回结果是否溢出？对于无符号整数乘法运算，当仅取乘积的低位作为乘法结果时，如何用 2n 位乘积进行溢出判断？
### 解
> [!done]+
> (1) 乘法运算可以通过加法和移位来实现。编译器可以将乘法运算转换为一个循环代码段，在循环代码段中通过比较、加法和移位等指令实现乘法运算。例如 Booth 乘法。
> 
> (2) 控制逻辑的作用是控制循环次数，控制加法和移位操作。
> 
> C 语言整型用补码表示，通常采用 Booth 乘法。
> 
> Booth 乘法对乘数从低位开始判断，根据两个数据位的情况决定进行加法、减法还是仅仅移位操作。判断的两个数据位为当前位及其右边的位（初始时需要增加一个辅助位 0），移位操作是向右移动。其中 booth 算法在操作时，需要遵循一个操作表：
> 
> $\begin{array}{|c|c|c|}\hline Y_n&Y_{n+1}&\text{操作}\\\hline 0&0&+0\text{，右移一位}\\\hline 0&1&+[X]_{\text{补}}\text{，右移一位}\\\hline 1&0&+[-X]_{\text{补}}\text{，右移一位}\\\hline 1&1&+0\text{，右移一位}\\\hline \end{array}$
> 
> 具体步骤如下：
> 
> 1. 被乘数_X_与乘数_Y_均以补码的形式参加乘法运算，运算结果是积的补码。
> 2. 部分积和被乘数_X_采用双符号位，乘数_Y_采用单符号位。
> 3. 初始部分积为 0。运算前，在乘数_Y_的补码末位添加一位附加位 $Y_{n+1}$ ，初始值为 0。
> 4. 根据 $Y_nY_{n+1}$ 的值，按照上表进行累加右移操作，右移时遵循补码的移位规则。
> 5. 累加 n+1 次，右移 n 次，最后一次不右移。
> 
> 这个过程累加 n+1 次，右移 n 次，所以控制逻辑的作用是控制循环次数，还需要根据操作表控制加法和移位操作。
> 
> (3) ①的执行时间最长，③的执行时间最短。
> 
> 对于①，需要使用其他指令和算法来模拟乘法操作。常见的方法是通过编写（软件）程序使用加法、位移和逻辑操作来实现乘法功能。这种方法通常需要多条指令和多个时钟周期来完成乘法运算，因此会比硬件乘法指令的执行时间更长。②和③都是硬件乘法指令，所以①的执行时间最长。
> 
> 对于②和③，都只需用一条乘法指令实现乘法操作。
> 
> 对于③，阵列乘法器是专门用于执行乘法操作的硬件电路，可以在一个时钟周期内完成乘法运算。由于其硬件实现的特性，阵列乘法器通常是执行乘法操作最高效的方式。所以③的执行时间最短。
> 
> 对于②，ALU 和位移器实现的乘法指令通常需要多个时钟周期来完成乘法运算。它通过将乘法操作划分为一系列的加法、位移和逻辑操作来实现。尽管比情况①中的方法更高效，但仍然需要多个时钟周期来执行，因此相对于情况③中的阵列乘法器，执行时间较长。
> 
> (4) 第一问。当 n=32、x= $2^{31}-1$ 、y=2 时，64 位的 [x] 补 = 0000 0000 0000 0000 0000 0000 0000 0000 0111 1111 1111 1111 1111 1111 1111 11111B，y=2，x×y 相当于对 x 进行算术左移 1 位，得到 [x×y] 补 = 0000 0000 0000 0000 0000 0000 0000 0000 1111 1111 1111 1111 1111 1111 1111 11110B=00000000FFFFFFFEH。
> 
> 第二问。此时函数 umul() 不溢出，imul() 的返回结果溢出，因为 umul() 的返回值类型为 unsigned，默认为 unsigned int，为 32 位无符号整型，可以表示 32 个数值位，结果恰有 32 个有效数值位，所以其返回结果不溢出。然而 imul() 返回值类型为 int，为 32 位有符号整型，最高位为符号位，可以表示 31 个数值位，结果有 32 个有效数值位，所以其返回结果溢出。
> 
> 第三问。对于无符号整数乘法运算，当仅取乘积的低位作为乘法结果时，对于 2n 位乘积，若乘积高 n 位全为 0，即乘积高 n 位不存在有效数值位，则无溢出，否则溢出。