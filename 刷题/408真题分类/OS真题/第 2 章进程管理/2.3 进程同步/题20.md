---
publish: true
tags: []
aliases: 
finished: true
title: 题20
created: "2024-11-02 07:00"
updated: "2024-12-16 13:25"
---
## 题20
### 题目
> [!question]+
> 【2022】某进程的两个线程 T1 和 T2 并发执行 A、B、C、D、E 和 F 共 6 个操作，其中 T1 执行 A、E 和 F，T2 执行 B、C 和 D。题 46 图表示上述 6 个操作的执行顺序所必须满足的约束：C 在 A 和 B 完成后执行，D 和 E 在 C 完成后执行，F 在 E 完成后执行。请使用信号量的 wait()、signal() 操作描述 T1 和 T2 之间的同步关系，并说明所用信号量的作用及其初值。
> ![](https://img.hwenyi.tech/202412162035399.webp)
### 分析
> [!NOTE]+
> [[刷题/25OS-王道/第 2 章 进程与线程/综合题/题26]]
> 
> 同步关系的PV操作，我们要先给出这个图的拓扑排序,作为执行顺序，然后我们的重点放在这个**依赖关系**上！
> 
> 任务前置任务有无$\begin{array}{ccc} \hline任务&前置任务\\ \hline A& 无\\ B&无\\ C&A,B\\ D&C\\ E& C\\F & E\end{array}$
> 
> > [!important]
> > 同步关系的PV操作，在执行任务前，要先完成相关的前置任务。例如，要执行B，B没有前置任务，所以直接signal解锁即可。然后要执行C，C的前置任务是A和B，所以要wait(S_AC)和wait(S_BC)将其锁上，才能执行C。执行完C后，要执行D和E，所以要signal(S_CD)和signal(S_CE)将其解锁。线程1执行E后，要signal(S_EF)解锁，保证F可达。线程2完成C后，要signal(S_CD)和signal(S_CE)解锁，保证D和E可达。总结来说，执行某个操作前，要将前置任务锁住；执行完后，要释放后续依赖任务的锁，保证后续任务可达，而前置任务不可达。
> 
> > [!cite]-
> > 好的，我们来一行一行地解释这段代码，看看它是如何让 T1 和 T2 按照题目要求的顺序执行的。
> > 
> > 首先，我们来复习一下 `wait()` 和 `signal()` 操作：
> > 
> > - `wait(S)`（也写作 `P(S)`）：如果信号量 `S` 的值大于 0，则将 `S` 的值减 1 并继续执行。如果 `S` 的值为 0，则进程/线程会被阻塞（暂停执行），直到 `S` 的值大于 0。
> > - `signal(S)`（也写作 `V(S)`）：将信号量 `S` 的值加 1。如果有线程因为 `wait(S)` 而阻塞，则会唤醒其中一个线程继续执行。
> > 
> > 现在，我们来看代码：
> > 
> > ```cpp
> > semaphore S_AC = 0;    //控制操作A和C的执行顺序
> > semaphore S_BC = 0;    //控制操作B和C的执行顺序
> > semaphore S_CD = 0;    //控制操作C和D的执行顺序
> > semaphore S_CE = 0;    //控制操作C和E的执行顺序
> > semaphore S_EF = 0;    //控制操作E和F的执行顺序
> > ```
> > 
> > - 这几行代码定义了5个信号量，初始值都是 0。这些信号量用于控制不同操作之间的执行顺序。
> > 
> > ```cpp
> > cobegin
> > Process T1() {
> >     // process A
> >     完成操作A;
> >     signal(S_AC);    // V(S_AC);
> >     // process E
> >     wait(S_CE);    // P(S_CE);
> >     完成操作E;
> >     signal(S_EF);    // V(S_EF);
> >     // process F
> >     wait(S_EF);    // P(S_EF);
> >     完成操作F;
> > }
> > ```
> > 
> > - `cobegin` 和 `coend` 表示 T1 和 T2 两个线程**并发执行**。
> > - 在 T1 中，首先执行 `完成操作A;`。
> > - 然后，`signal(S_AC);` 将 `S_AC` 的值加 1。这表示操作 A 已经完成，可以通知其他线程了。
> > - 接下来，`wait(S_CE);` T1 会等待 `S_CE` 大于 0 才能继续执行，这时 T1 可能会被阻塞，如果 `S_CE` 为 0 的话。
> > - 在 `wait(S_CE);` 之后，T1 执行 `完成操作E;`。
> > - 然后，`signal(S_EF);` 将 `S_EF` 的值加 1。这表示操作 E 已经完成。
> > - `wait(S_EF);` T1 会等待 `S_EF` 大于 0 才能继续执行，这时 T1 可能会被阻塞，如果 `S_EF` 为 0 的话。
> > - 最后，T1 执行 `完成操作F;`。
> > 
> > ```cpp
> > Process T2() {
> >     // process B
> >     完成操作B;
> >     signal(S_BC);    // V(S_BC);
> >     // process C
> >     wait(S_AC);    // P(S_AC);
> >     wait(S_BC);    // P(S_BC);
> >     完成操作C;
> >     signal(S_CD);    // V(S_CD);
> >     signal(S_CE);    // V(S_CE);
> >     // process D
> >     wait(S_CD);    // P(S_CD);
> >     完成操作D;
> > }
> > ```
> > 
> > - 在 T2 中，首先执行 `完成操作B;`。
> > - 然后，`signal(S_BC);` 将 `S_BC` 的值加 1。这表示操作 B 已经完成，可以通知其他线程了。
> > - 接下来，`wait(S_AC);` T2会等待 `S_AC` 大于 0 才能继续执行，这时 T2 可能会被阻塞，如果 `S_AC` 为 0 的话。
> > - 然后，`wait(S_BC);` T2会等待 `S_BC` 大于 0 才能继续执行，这时 T2 可能会被阻塞，如果 `S_BC` 为 0 的话。
> > - 在 `wait(S_AC);` 和 `wait(S_BC);` 之后，T2 执行 `完成操作C;`。
> > - 然后，`signal(S_CD);` 将 `S_CD` 的值加 1。这表示操作 C 已经完成。
> > - 然后，`signal(S_CE);` 将 `S_CE` 的值加 1。这表示操作 C 已经完成。
> > - 接下来，`wait(S_CD);` T2 会等待 `S_CD` 大于 0 才能继续执行，这时 T2 可能会被阻塞，如果 `S_CD` 为 0 的话。
> > - 最后，T2 执行 `完成操作D;`。
> > 
> > **同步关系**
> > 
> > - **A 和 C 的同步：**
> >     - T1 完成 A 后，`signal(S_AC)` 将 `S_AC` 加 1。
> >     - T2 在执行 C 之前，需要 `wait(S_AC)`，等待 `S_AC` 大于 0。这确保了 C 必须在 A 完成后执行。
> > - **B 和 C 的同步：**
> >     - T2 完成 B 后，`signal(S_BC)` 将 `S_BC` 加 1。
> >     - T2 在执行 C 之前，需要 `wait(S_BC)`，等待 `S_BC` 大于 0。这确保了 C 必须在 B 完成后执行。
> > - **C 和 D 的同步：**
> >     - T2 完成 C 后，`signal(S_CD)` 将 `S_CD` 加 1。
> >     - T2 在执行 D 之前，需要 `wait(S_CD)`，等待 `S_CD` 大于 0。这确保了 D 必须在 C 完成后执行。
> > - **C 和 E 的同步：**
> >     - T2 完成 C 后，`signal(S_CE)` 将 `S_CE` 加 1。
> >     - T1 在执行 E 之前，需要 `wait(S_CE)`，等待 `S_CE` 大于 0。这确保了 E 必须在 C 完成后执行。
> > - **E 和 F 的同步：**
> >     - T1 完成 E 后，`signal(S_EF)` 将 `S_EF` 加 1。
> >     - T1 在执行 F 之前，需要 `wait(S_EF)`，等待 `S_EF` 大于 0。这确保了 F 必须在 E 完成后执行。
> > 
> > **运行过程模拟**
> > 
> > 1. T1 和 T2 同时开始执行。
> > 2. T1 执行 A，然后 `signal(S_AC)`，`S_AC` 变为 1。
> > 3. T2 执行 B，然后 `signal(S_BC)`，`S_BC` 变为 1。
> > 4. T2 执行 `wait(S_AC)`，因为 `S_AC` 为 1，所以继续执行。
> > 5. T2 执行 `wait(S_BC)`，因为 `S_BC` 为 1，所以继续执行。
> > 6. T2 执行 C，然后 `signal(S_CD)`，`S_CD` 变为 1, `signal(S_CE)`，`S_CE` 变为 1。
> > 7. T2 执行 `wait(S_CD)`，因为 `S_CD` 为 1，所以继续执行。
> > 8. T2 执行 D。
> > 9. T1 执行 `wait(S_CE)`，因为 `S_CE` 为 1，所以继续执行。
> > 10. T1 执行 E，然后 `signal(S_EF)`，`S_EF` 变为 1。
> > 11. T1 执行 `wait(S_EF)`，因为 `S_EF` 为 1，所以继续执行。
> > 12. T1 执行 F。
> > 
> > 这样，就保证了 A 和 B 在 C 之前执行，C 在 D 和 E 之前执行，E 在 F 之前执行。
### 解
> [!done]+
> [[刷题/408历年真题解析/2022年408真题操作系统篇/题46]]