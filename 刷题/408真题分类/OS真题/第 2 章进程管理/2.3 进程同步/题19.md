---
publish: true
tags: []
aliases: 
finished: true
title: 题19
created: "2024-11-02 07:00"
updated: "2024-12-17 02:23"
---
## 题19
### 题目
【2021】下表给出了整型信号量 $\mathrm{S}$ 的 wait () 和 signal () 操作的功能描述,以及采用开/关中断指令实现信号量操作互斥的两种方法。
![](https://img.hwenyi.tech/202411041851652.webp)
请回答下列问题。
1. 为什么在 wait () 和 signal () 操作中对信号量 $\mathrm{S}$ 的访问必须互斥执行?
2. 分别说明方法 1 和方法 2 是否正确。若不正确, 请说明理由。
3. 用户程序能否使用开/关中断指令实现临界区互斥? 为什么?
### 分析
[[刷题/408真题分类/OS真题/第 2 章进程管理/2.3 进程同步/题20]]

1. **`wait()` 的目的**：`wait()` 的主要目的是，当资源不可用时（`S <= 0`），让进程等待。一旦资源可用，就减少信号量 `S` 的值，并继续执行。这本身就是一个需要互斥的操作。
2. **方法 1 的问题**:
   - **关中断**: 在方法1中，`wait()`操作开始时，会先关中断。
   - **死循环**: 如果 `S <= 0`, 进程会进入 `while` 循环。因为关了中断，其他进程的`signal`操作无法执行，`S` 的值无法改变，循环就永远不会结束，造成死循环。
3. **方法 2 的目的**:
   - **关中断**: 和方法1一样，`wait()`操作开始时，会先关中断。
   - **短暂开中断**: 方法2在while循环中加入了开中断和关中断操作。
   - **解决死循环**: 这样的话，如果`S <= 0`, 进程会在`while`循环中短暂地开中断。让其他进程有机会执行，可能执行`signal`操作，并增加`S`的值，避免了死循环。
4. **关于原子性**
    - 你说的没错，`wait()`操作本身需要原子性，否则会造成竞争条件，例如两个进程同时执行`S = S - 1`可能会导致`S`的值错误减少。
    - 方法2通过关中断和开中断的**配合**，使得在修改`S`值**之前**，临界区是互斥的，即，**修改`S`值的操作是原子的。**

简单来说，方法2的`while`循环里面的`开中断`和`关中断`的操作，是为了避免方法1死循环的问题，而不是破坏了`wait`操作的原子性。`wait`操作的原子性是通过关中断来保证的。

**总结一下**：
- `wait()` 操作本身是为了实现互斥。
- 方法 1 的问题在于死循环，由于关中断导致其他进程无法改变 `S` 的值。
- 方法 2 通过在 `while` 循环中短暂地开中断，解决了死循环的问题。`while`循环里开中断的目的是为了让别的进程可以修改`S`的值，而不是为了破坏`wait`操作的原子性。
- **关中断是在`S = S - 1`这样的临界区代码执行前确保互斥的关键。**
- **只有当临界区里的代码执行完后才会开中断，这样可以确保临界区代码执行期间的原子性**。

### 解
[[刷题/408历年真题解析/2021年408真题操作系统篇/题45]]