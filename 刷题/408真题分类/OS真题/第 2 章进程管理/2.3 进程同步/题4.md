---
publish: true
tags: 
aliases: 
finished: true
title: 题4
created: "2024-11-02 07:00"
updated: "2024-11-05 01:37"
---
## 题4
### 题目
> [!question]+
> 【2016】使用 TSL(TestandSetLock) 指令实现进程互斥的伪代码如下所示:
> ```c
> do {
>     // ...
>     while (TSL(&lock));
>     critical section;
>     lock = FALSE;
>     // ...
> } while (TRUE);
> ```
> 下列与该实现机制相关的叙述中, 正确的是( )。 
> A. 退出临界区的进程负责唤醒阻塞态进程
> B. 等待进入临界区的进程不会主动放弃 CPU
> C. 上述伪代码满足 “让权等待” 的同步准则
> D. while (TSL (&lock)) 语句应在关中断状态下执行
### 分析
> [!NOTE]+
> 我的理解是，哪怕是皮尔森算法也没有解决[[互斥]]中让权等待的问题，所谓的让权等待，也就是，让得不到cpu资源的进程，不要轮询cpu的状态，而是直接放弃掉，先不要管cpu，不然一直轮询，cpu开销很大，自己也是一直等着，也干不了啥。这个问题，直到80年代开始推广[[信号量]]机制，用pv操作才解决
### 解
> [!done]+
> 【参考答案】B
> 【解析】TSL[[指令]]属于硬件[[同步]]机制。标志（Flag）可以被看作是一把锁，"锁开"对应进入，"锁关"对应等待。
> **TSL[[指令]]无法实现让权等待**，[[进程]]在无法进入[[临界区]]时会一直占用CPU资源，因此不存在被阻塞的情况，退出临界区的进程也不会唤醒其他进程，A和C错误；等待进入临界区时，持续执行while循环，也就持续占用CPU，B正确；若while循环在[[关中断]]状态下执行，则系统无法响应其他中断源的中断请求；而且TSL是原子操作，无需中断来保证"锁"的互斥访问，D错误。故本题选B。