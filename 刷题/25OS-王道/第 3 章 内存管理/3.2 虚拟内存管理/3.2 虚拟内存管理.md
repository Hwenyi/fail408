---
publish: true
aliases: 
tags: []
finished: true
created: 2024-07-23 05:05
updated: 2024-09-21 13:12
title: 3.2 虚拟内存管理
TARGET DECK: 刷题::25OS-王道::第 3 章 内存管理::3.2 虚拟内存管理
---
# MOC

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题1]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题2]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题3]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题4]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题5]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题6]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题7]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题8]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题9]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题10]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题11]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题12]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题13]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题14]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题15]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题16]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题17]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题18]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题19]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题20]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题21]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题22]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题23]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题24]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题25]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题26]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题27]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题28]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题29]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题30]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题31]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题32]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题33]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题34]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题35]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题36]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题37]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题38]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题39]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题40]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题41]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题42]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题43]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题44]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题45]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题46]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题47]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题48]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题49]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题50]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题51]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题52]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题53]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题54]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题55]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题56]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题57]]

[[刷题/25OS-王道/第 3 章 内存管理/3.2 虚拟内存管理/题58]]

## 虚拟内存的基本概念

Q: 传统存储管理方式存在哪些问题？
A: ① 作业必须一次性全部装入内存才能运行，导致内存利用率低，且无法运行大型作业。
② 作业装入内存后，会一直驻留，即使部分内容暂时不用，也会占用内存空间，造成浪费。

Q: 什么是局部性原理？
A: 局部性原理是指程序在执行时，倾向于访问内存中靠近当前访问地址的指令和数据。

Q: 局部性原理表现在哪两个方面？
A: 时间局部性：程序在一段时间内会重复访问同一个指令或数据，例如循环结构。
空间局部性：程序在一段时间内会访问相邻的内存地址，例如数组和向量。

Q: 什么是虚拟存储器？
A: 虚拟存储器是一种利用外存来扩充内存的技术，它为用户提供了一个比实际物理内存大得多的逻辑地址空间。

Q: 虚拟存储器的三个主要特征是什么？
A: ① 多次性：作业无需一次性全部装入内存，可分多次调入。
② 对换性：作业运行时无需一直驻留内存，可将暂时不用的部分换出到外存。
③ 虚拟性：逻辑上扩充了内存容量，使用户看到的内存容量远大于实际容量。

Q: 虚拟内存技术主要有哪三种实现方式？
A: 请求分页存储管理、请求分段存储管理和请求段页式存储管理。

Q: 实现虚拟内存技术需要哪些硬件支持？
A: ① 一定容量的内存和外存 
② 页表机制（或段表机制） 
③ 中断机构 
④ 地址变换机构。

## 请求分页管理方式

### 页表机制

Q: 请求分页系统中的页表项包含哪些字段？
A: 页号、物理块号、状态位 P、访问字段 A、修改位 M 和外存地址。

Q: 页表项中的状态位 P 的作用是什么？
A: 标记该页是否已调入内存。

Q: 页表项中的访问字段 A 的作用是什么？
A: 记录本页的访问情况，例如访问次数或最近访问时间，供页面置换算法参考。

Q: 页表项中的修改位 M 的作用是什么？
A: 标记该页在调入内存后是否被修改过，决定换出时是否需要写回外存。

Q: 页表项中的外存地址的作用是什么？
A: 记录该页在外存的存放地址，供调入页面时参考。

### 缺页中断机构

Q: 什么是缺页中断？
A: 当进程访问的页面不在内存时，会产生缺页中断，请求操作系统将所需页面调入内存。

Q: 缺页中断处理程序主要完成哪些任务？
A: ① 查找页表，获取缺页在外存的地址。② 分配页框，将缺页从外存调入内存。③ 更新页表，包括状态位、访问位、修改位等。

Q: 缺页中断与一般中断相比有哪些区别？
A: ① 缺页中断在指令执行期间产生和处理，属于内部异常，而一般中断在指令执行完成后产生。② 一条指令执行期间可能产生多次缺页中断，而一般中断一次指令只会产生一次。

### 地址变换机构

Q: 请求分页系统中的地址变换过程是怎样的？
A: ① 检索快表 (TLB)，若命中，直接获取物理地址。
② 若 TLB 未命中，检索页表，若命中，获取物理地址，并将该页表项加入 TLB。
③ 若页表未命中，产生缺页中断，将缺页调入内存，更新页表和 TLB。
④ 最后根据物理地址访问内存。

Q: 缺页中断处理程序是如何将缺页调入内存的？
A: ① 发生缺页中断，CPU 保存当前进程的上下文信息，并将控制权交给操作系统。
② 操作系统检查页表，找到缺页的磁盘地址。
③ 若内存有空闲页框，分配给缺页，并将缺页从磁盘调入。
④ 更新页表，将缺页的物理块号写入页表。
⑤ 恢复进程的上下文信息，将控制权返回给进程。

## 页框分配

### 驻留集大小

Q: 什么是驻留集？
A: 驻留集是指分配给一个进程的页框的集合。

Q: 驻留集大小对系统性能有何影响？
A: 驻留集过小会导致频繁缺页中断，降低性能。驻留集过大会浪费内存资源，降低系统并发度。理想的驻留集大小应与进程的工作集大小相匹配。

### 内存分配策略

Q: 请求分页系统中常用的三种内存分配策略是什么？
A: ① 固定分配局部置换：每个进程分配固定数目的页框，缺页时只能从该进程的页框中选择一页换出。
② 可变分配全局置换：每个进程分配一定数目的页框，缺页时可从系统所有空闲页框中选择一页换出。
③ 可变分配局部置换：每个进程分配一定数目的页框，缺页时只能从该进程的页框中选择一页换出，但可根据缺页率动态调整页框数。

Q: 固定分配局部置换策略的优缺点是什么？
A: 优点：实现简单。缺点：难以确定合适的页框数，页框数太少会导致频繁缺页中断，太多则浪费内存。

Q: 可变分配全局置换策略的优缺点是什么？
A: 优点：比固定分配策略更灵活，可动态调整页框数。缺点：可能导致某些进程占用过多页框，降低系统并发度。

Q: 可变分配局部置换策略的优缺点是什么？
A: 优点：兼顾了进程的独立性和系统的整体性能。缺点：实现更复杂，开销更大。

### 物理块调入算法

Q: 常见的物理块调入算法有哪些？
A: ① 平均分配算法：将空闲物理块平均分配给各个进程。
② 按比例分配算法：根据进程的大小按比例分配物理块。
③ 优先权分配算法：为重要或紧急的进程分配更多物理块。

### 调入页面的时机

Q: 常见的调页策略有哪些？
A: ① 预调页策略：根据局部性原理，预测进程可能访问的页面，预先调入内存。
② 请求调页策略：进程需要访问某个页面时才调入内存。

Q: 预调页策略的优缺点是什么？
A: 优点：若预测准确，可减少缺页中断次数。缺点：若预测错误，会调入不需要的页面，浪费内存。

Q: 请求调页策略的优缺点是什么？
A: 优点：调入的页面一定会被访问，实现简单。缺点：每次只调入一页，增加磁盘 I/O 开销。

### 从何处调入页面

Q: 请求分页系统中，当发生缺页请求时，系统可能从哪里调入页面？
A: ① 若有足够对换区空间，则从对换区调入。
② 若对换区空间不足，未修改的文件从文件区调入，可能修改的文件从对换区调入。
③ UNIX 方式：未运行过的页面从文件区调入，运行过的页面从对换区调入。

### 如何调入页面

Q: 缺页中断处理程序如何调入页面？
A: ① 查找页表，获取缺页的物理块号。
② 若内存未满，分配页框，将缺页从外存调入，修改页表。
③ 若内存已满，选择一页换出，将缺页调入，修改页表。

## 页面置换算法

Q: 什么是页面置换算法？
A: 当内存没有空闲页框时，需要调入新页面，页面置换算法用于选择换出哪个页面到外存。

Q: 常见的页面置换算法有哪些？
A: 最佳置换算法 (OPT)、先进先出置换算法 (FIFO)、最近最久未使用置换算法 (LRU) 和时钟置换算法 (CLOCK)。

### 最佳 (OPT) 置换算法

Q: 什么是最佳置换算法 (OPT)？
A: OPT 算法选择淘汰以后永不使用的页面，或者是在最长时间内不再被访问的页面。

Q: OPT 算法的特点是什么？
A: OPT 算法可保证最低的缺页率，但无法预测未来页面访问情况，因此无法实现，主要用于理论分析和评价其他算法。

### 先进先出 (FIFO) 页面置换算法

Q: 什么是先进先出置换算法 (FIFO)？
A: FIFO 算法选择淘汰最早进入内存的页面。

Q: FIFO 算法的特点是什么？
A: 实现简单，但性能较差，可能出现 Belady 异常，即分配的物理块数增加，缺页次数反而增加。

### 最近最久未使用 (LRU) 置换算法

Q: 什么是最近最久未使用置换算法 (LRU)？
A: LRU 算法选择淘汰最近最长时间未被访问的页面。

Q: LRU 算法的特点是什么？
A: 性能较好，接近 OPT 算法，但需要硬件支持来记录页面访问时间，实现开销较大。

### 时钟 (CLOCK) 置换算法

Q: 什么是时钟置换算法 (CLOCK)？
A: CLOCK 算法是一种近似 LRU 算法的页面置换算法，为每个页面设置一个访问位，使用指针循环扫描页面。

Q: 时钟置换算法分为哪两种？
A: 简单 CLOCK 算法和改进型 CLOCK 算法。

Q: 简单 CLOCK 算法的特点是什么？
A: 只考虑页面的访问位，淘汰访问位为 0 的页面。

Q: 改进型 CLOCK 算法的特点是什么？
A: 同时考虑页面的访问位和修改位，优先淘汰未被访问且未被修改的页面，减少磁盘 I/O 次数。

## 抖动和工作集

### 抖动

Q: 什么是抖动？
A: 抖动是指页面置换过程中，频繁发生页面换入换出的现象，导致系统性能下降，大部分时间花费在页面置换上。

Q: 抖动产生的原因是什么？
A: 分配给进程的物理块太少，导致缺页率过高。

Q: 如何解决抖动？
A: 增加分配给进程的物理块数，降低缺页率，或者减少并发进程数，降低系统负载。

### 工作集

Q: 什么是工作集？
A: 工作集是指在某段时间间隔内，进程实际要访问的页面的集合。

Q: 工作集对系统性能有何影响？
A: 若分配给进程的物理块数小于工作集的大小，会导致频繁缺页中断，降低系统性能。

Q: 什么是工作集模型？
A: 工作集模型根据进程的工作集大小动态调整驻留集大小，避免抖动，提高系统性能。

## 内存映射文件

Q: 什么是内存映射文件？
A: 内存映射文件将磁盘文件映射到进程的虚拟地址空间，进程可像访问内存一样访问文件，由操作系统负责文件内容的读写。

Q: 内存映射文件的优点是什么？
A: ① 简化文件访问操作，无需使用文件 I/O 系统调用。
② 方便进程间共享文件，多个进程可映射同一个文件到各自的虚拟地址空间，实现数据共享。

## 虚拟存储器性能影响因素

Q: 影响虚拟存储器性能的主要因素是什么？
A: 缺页率，即页面不在内存中导致缺页中断的频率。

Q: 哪些因素会影响缺页率？
A: 页面大小、分配给进程的物理块数、页面置换算法和程序的编制方法。

Q: 页面大小对缺页率有何影响？
A: 页面过小，页表过长，占用内存，缺页率较高。页面过大，页内碎片过多，浪费内存。

Q: 分配给进程的物理块数对缺页率有何影响？
A: 物理块数越多，缺页率越低，但超过一定程度后，缺页率下降不明显，反而浪费内存。

Q: 页面置换算法对缺页率有何影响？
A: 不同的算法导致不同的缺页率，LRU 算法的缺页率通常较低。

Q: 程序的编制方法对缺页率有何影响？
A: 程序局部性越好，缺页率越低。应尽量使程序顺序访问内存，避免跳跃式访问。

## 虚拟地址翻译

Q: 虚拟地址翻译成物理地址的过程是怎样的？
A: ① CPU 将虚拟地址送入内存管理单元 (MMU)。
② MMU 检索 TLB，若命中，直接获取物理地址。
③ 若 TLB 未命中，检索页表，若命中，获取物理地址，并将该页表项加入 TLB。
④ 若页表未命中，产生缺页中断，操作系统将缺页调入内存，更新页表和 TLB。
⑤ MMU 将物理地址送回 CPU，CPU 访问内存。

## 虚拟内存空间的大小

Q: 虚存的容量受哪些因素限制？
A: ① 实际容量受内存和外存容量之和限制。
② 最大容量受计算机地址位数限制。

Q: 如何计算虚存的实际容量和最大容量？
A: 实际容量 = 内存容量 + 外存容量，但实际使用受操作系统和硬件限制。最大容量由地址位数决定，例如 32 位系统最大可访问 4 GB 虚拟内存空间。

