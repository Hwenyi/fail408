## 题23
### 题目
【2019 统考真题】有 $n( {n \geq  3})$ 名哲学家围坐在一张圆桌边,每名哲学家交替地就餐和思考。在圆桌中心有 $m( {m \geq  1})$ 个碗,每两名哲学家之间有一根筷子。每名哲学家必须取到一个碗和两侧的筷子后, 才能就餐, 进餐完毕, 将碗和筷子放回原位, 并继续思考。为使尽可能多的哲学家同时就餐,且防止出现死锁现象,请使用信号量的`P`、`V` 或 `wait()`、`signal()` 操作描述上述过程中的互斥与同步, 并说明所用信号量及初值的含义。
### 分析
[[哲学家吃饭]]的问题核心在于，不能让每个人都只拿到了部分，必须让一个人一次性拿到所有资源，先吃，再让其他人吃，如果不让一个人先吃，则永远没有人可以吃上
### 解
```c
//定义资源，这里是筷子和碗
semaphore kuaizi[5] = {1, 1, 1, 1, 1}; //筷子
semaphore bowl = m; //碗

semaphore mutex = 1; //互斥锁


//定义哲学家进程
void zhexuejia(i) { //第几个哲学家
//检查所需的所有资源是否可以使用，如果可以，那么就取走所有所需资源，每次在饭桌上找资源的时候，锁住饭桌

while(1) {
	P(mutex); //锁住饭桌
	//检查自己所需的全部资源是否都在
	if((bowl>=0) && (kuaizi[i]==1) && (kuaizi[i+1]%5)==1) { //碗和左右两边的筷子都可以拿
		//把资源都拿出来用
		bowl--;
		kuaizi[i]--;
		kuaizi[(i+1)%5]--;
		V(mutex); //解锁饭桌
		//拿到资源，完成任务，退出
		break;
	}
		else {
		  V(mutex); //解锁饭桌，因为当时检查的时候给锁住了
		  思考;//如果资源不够，那么就等待
  }
}
		吃饭;

		P(mutex); //锁住饭桌，把筷子换回去，不能让别人哄抢，必须锁住
		//吃完饭了，把资源放回去
		bowl++;
		kuaizi[i]++;
		kuaizi[(i+1)%5]++;
		V(mutex); //解锁饭桌，三二一，开抢！
}
```
