---
publish: true
tags: 
aliases: 
finished: true
title: 题08
created: "2024-11-21 06:59"
updated: "2024-11-21 07:40"
---
## 题08
### 题目
> [!question]+
> 已知字符串 S 为 “abaabaabacacaabaabcc”，模式串 t 为 “abaabc”。采用 KMP 算法进行匹配，第一次出现 “失配”（S[i] ≠ t[j]）时，i = j = 5，则下次开始匹配时，i 和 j 的值分别是（ ）。
> 
> A. i = 1, j = 0
> 
> B. i = 5, j = 0
> 
> C. i = 5, j = 2
> 
> D. i = 6, j = 2
### 解
> [!done]+
> **方法一：模拟**
> 
> 设模式为 $P[1:m]$ ，文本为 $T[1:n]$ ，初始时偏移为 _s_ = 0。
> 
> 设当前偏移为 _s_，需要从前往后依次比较 $P[1:m]$ 和 $T[1+s:m+s]$ ，若 $P[1:m]=T[1+s:m+s]$ ，则匹配成功，得到 _P_ 在 _T_ 中的一个匹配。
> 
> 若中间出现失配，设在 _P_ 的第 $i$ 个位置出现失配，即有 $P[i]\ne T[i+s]$ ，则需要利用已匹配部分 $P[1:i-1]$ 和 $T[1+s:i-1+s]$ 的信息。
> 
> 以下以 _T_ = bacbababaabcbab 和 _P_ = ababaca 为例。_P_ 中绿色（含浅绿色和深绿色）表示对应字符匹配，红色表示对应字符失配，灰色表示未比较，浅绿色表示已匹配部分的最长的相等的前缀，深绿色表示已匹配部分的最长的相等的后缀。_T_ 中黄色表示对应字符已经比较过，灰色表示未比较。
> 
> ![](https://picx.zhimg.com/v2-c8934defcf3ebe6884a318d43b098ccf_r.jpg)
> 
> 若已匹配部分为空，则 _P_ 继续偏移一个位置，即偏移 _s_ 增加 1。如图中第 1 趟、第 3 趟和第 4 趟匹配。
> 
> 若已匹配部分不为空，已匹配长度为 x = _i_ - 1，找出已匹配部分的最长的相等的前缀和后缀，（寻找已匹配部分的最长的相等的前缀和后缀时，从长度为 _x_ - 1 的前缀和后缀开始判断更好。）该长度为 _y_，则下一次匹配从后缀开始位置开始，即偏移 _s_ 增加 _x - y_。如图中第 2 趟和第 5 趟匹配。这步跳转用到了等式的传递性，因为 $P[1:y] = P[x-y+1:x]$ 且 $P[x-y+1:x] = T[x-y+1+s:x+s]$ ，所以 $P[1:y] = T[x-y+1+s:x+s]$ 。KMP 算法强大的地方就在这里，相比朴素字符串匹配算法，偏移 _s_ 不仅实现了跳跃式增长，而且下一趟匹配中当前这趟的前缀部分的无需重新比较。
> 
> 接下来进入下一轮匹配，从 _P_ 中未比较的灰色部分开始继续比较，重复上述过程直到找到一个匹配或者比较超出 _T_ 的范围为止。
> 
> 回到本题：
> 
> ![](https://pic3.zhimg.com/v2-d55d175bc3bd6a7a6a29c6e9b996ef24_r.jpg)
> 
> 本题选 **C。**
> 
> **方法二：计算 next 数组**
> 
> 第一步：计算出模式串的 next 数组。
> 
> 第一次出现 “失配”（s[i] ≠ t[j]）时，i = j = 5，隐藏含义是主串和模式串下标都从 0 开始，这个条件非常重要。
> 
> 第一步：计算未修正的 next 数组
> 
> - 当 i = 0 时，next[i] = -1；
> - 当 i = 1 时，next[i] = 0；
> - 当 i = 2, 3, … 时，next[i] = S[0 : i-1] 的最长相等前缀和后缀的长度。
> 
> 可以计算表格如下：
> 
> <table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td>下标 i</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>字符 t[i]</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>c</td></tr><tr><td>next[i]</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>2</td></tr></tbody></table>
> 
> 第二步：移动模式串
> 
> - 方法一：计算移动距离
> 
> 模式串失配后移动距离 = 失配字符下标 - 失配字符下标对应 next 值
> 
> 当 S[i] ≠ t[j]，模式串 t 的移动距离 = j - next[j]。
> 
> 当 i = j = 5 时，模式串 t 的移动距离 = 5 - next[5] = 5 - 2 = 3。
> 
> 移动后，i = 5, j = 2。
> 
> - 方法二：指针对齐
> 
> 模式串失配后将指针移动到失配字符下标对应 next 值处，并重新与文本串进行比较
> 
> 当 S[i] ≠ t[j]，将模式串 t 指针 j 移动到 next[j] 处，并移动模式串 t 将指针 i 与指针 j 对齐。
> 
> 当 i = j = 5 时，文本串 S 的指针 i = 5 不动，模式指串指针 j 移动到 next[5] = 2 处，并移动模式串 t 将指针 i 与指针 j 对齐。
> 
> 移动后，i = 5, j = 2。
> 
> ![](https://pic1.zhimg.com/v2-84d7d445b53c2763fb05cd1415e91146_r.jpg)
> 
> 本题选 **C**。
> 
> **方法三：贪心**
> 
> 贪心找到下一个出现匹配字符最多的情况，同样画出上图。虽然这个方法不严谨，好在本题足够简单，从失配位置开始重新进行匹配，很容易看到 i = 5, j = 2。
> 
> 本题选 **C**。
> 
> _**举一反三**_
> 
> 已知字符串 S 为 “abaabaabacacaabaabcc”，模式串 t 为 “abaabc”。采用 KMP 算法进行匹配，在第一次匹配成功前，出现 “失配”（S[i] ≠ t[j]）的次数为
> 
> A. 2
> 
> B. 4
> 
> C. 6
> 
> D. 8
> 
> 参考答案：D
> 
> 补充本人对本题完整 KMP 匹配过程的模拟。
> 
> ![](https://picx.zhimg.com/v2-71f3ffc42c0b0168a9d79efe633b5649_r.jpg)
> 
> 评：本题在 2019 年第 9 题也会换个方式继续对 KMP 进行考察，巧的是两题的模式串完全相同，可见掌握好历年真题非常重要。