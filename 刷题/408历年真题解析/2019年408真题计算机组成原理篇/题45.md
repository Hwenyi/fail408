---
publish: true
tags: 
aliases: 
finished: true
title: 题45
created: "2024-11-21 07:21"
updated: "2024-11-21 07:40"
---
## 题45
### 题目
> [!question]+
> （16 分）
> 
> 已知 `f(n) = n! =n×(n-1)×(n-2)×…×2×1`，计算 f(n) 的 C 语言函数 f1 的源程序（阴影部分）及其在 32 位计算机 M 上的部分机器级代码如下：
> 
> ```cpp
> int f1(int n){
> 1   00401000  55              push ebp
>     ...       ...             ...
> if(n>1)
> 11  00401018  83 7D 08 01     cmp dword ptr [ebp+8],1
> 12  0040101C  7E 17           jle f1+35h (00401035)
> return n*f1(n-1);
> 13  0040101E  8B 45 08        mov eax, dword ptr [ebp+8]
> 14  00401021  83 E8 01        sub eax, 1
> 15  00401024  50              push eax
> 16  00401025  E8 D6 FF FF FF  call f1 (00401000)
>     ...       ...             ...
> 19  00401030  0F AF C1        imul eax, ecx
> 20  00401033  EB 05           jmp f1+3Ah (0040103a)
> else return 1;
> 21  00401035  B8 01 00 00 00  mov eax, 1
> }
>     ...       ...             ...
> 26  00401040  3B EC           cmp ebp, esp
>     ...       ...             ...
> 30  0040104A  C3              ret
> ```
> 
> 其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令，计算机 M 按字节编址，int 型数据占 32 位。请回答下列问题：
> 
> (1) 计算 f(10) 需要调用函数 f1 多少次？执行哪条指令会递归调用 f1？
> 
> (2) 上述代码中，哪条指令是条件转移指令？哪几条指令一定会使程序跳转执行？
> 
> (3) 根据第 16 行的 call 指令，第 17 行指令的虚拟地址应是多少？已知第 16 行的 call 指令采用相对寻址方式，该指令中的偏移量应是多少（给出计算过程）？已知第 16 行的 call 指令的后 4 字节为偏移量，M 是采用大端方式还是采用小端方式？
> 
> (4) f(13)=6227020800，但 f1(13) 的返回值为 1932053504，为什么两者不相等？要使 f1(13) 能返回正确的结果，应如何修改 f1 的源程序？
> 
> (5) 第 19 行的 imul 指令（带符号整数乘）的功能是 `R[eax]←R[eax]×R[ecx]`，当乘法器输出的高、低 32 位乘积之间满足什么条件时，溢出标志 OF=1？要使 CPU 在发生溢出时转异常处理，编译器应在 imul 指令后应加一条什么指令？
### 解
> [!done]+
> (1) 第一问。观察 f1 的 C 语言代码，可知 f1(n) 用递归方法计算 n!，计算 f(10) 需要调用函数 f1 共 10 次。
> 
> 第二问。执行第 16 行的指令会递归调用 f1。
> 
> 方法一：观察 f1 的汇编代码，第 16 行 call f1，表示递归调用 f1。
> 
> 方法二：观察 f1 的指令地址，第 16 行跳转到第 1 行的地址 00401000 执行，表示从头开始执行 f1。
> 
> (2) 第一问。观察 f1 的汇编语言代码，可知第 12 行 jle (jump when less or equal) 指令是条件转移指令。结合 f1 的 C 语言代码分析可知，n<=1 为真时跳转到 else 分支，n>1 为真时执行 if 的第一个分支。因为 n<=1 不一定为真，所以该条件转移指令不一定会使程序跳转执行。
> 
> 第二问。观察 f1 的汇编语言代码，可知
> 
> - 第 16 行 call 指令为递归调用 f1，对应代码 f1(n-1)，一定会使程序跳转执行。
> - 第 20 行 jmp (jump) 指令为无条件跳转指令，一定会使程序跳转执行。
> - 第 30 行 ret (return) 指令为返回指令，一定会使程序跳转执行。
> 
> (3) 第一问。第 17 行指令为第 16 行指令的下一条指令，第 16 行指令的虚拟地址为 00401025H，指令内容为”E8 D6 FF FF FF“（从左到右为从低字节到高字节的内容），占 5 个字节，计算机 M 按字节编址，第 16 行指令占 5 个地址单元，所以第 17 行指令的虚拟地址为 00401025H+5H=0040102AH。
> 
> 第二问。已知第 16 行的 call 指令采用相对寻址方式，即目标地址 =(PC)+ 偏移量，call 指令的目标地址为 00401000H，(PC) 为第 16 行指令的下一条指令的虚拟地址，即 17 行指令的虚拟地址，根据第一问的结果，(PC)=0040102AH，所以偏移量 = 目标地址 -(PC)=00401000H-0040102AH=FFFFFFD6H。
> 
> 第三问。已知第 16 行的 call 指令的后 4 字节为偏移量，偏移量字段为 “D6 FF FF FF”（从左到右为从低字节到高字节的内容），偏移量内容为 FFFFFFD6H，低字节内容存储在低地址，可确定 M 采用小端方式。
> 
> (4) 第一问。因为 f1 返回值类型为 int，int 型数据占 32 位，int 的表示范围为 $-2^{31}\sim 2^{31}-1$ ，即 - 2147483648~2147483647，f(13)=6 227 020 800 大于 32 位 int 型数据可表示的最大值，因而 f1(13) 的返回值是一个发生了溢出的结果。
> 
> 第二问。为使 f1(13) 能返可正确结果，可将函数 f1 的返回值类型改为具有更大表示范围的 long long（或 double 或 long double 或 float）。一般数值用 int 表示溢出情况下改为 long long，因为 int 和 long long 都是整型。
> 
> 注：6227020800= 1 0111 0011 0010 1000 1100 1100 0000 0000B，如果用浮点数表示，则二进制有效数值位至少有 23 位。因为 float 最多可以表示 24 位二进制有效数值位，所以转 float 不会出现精度丢失。
> 
> (5) 第一问，若乘积的高 33 位为非全 0 或非全 1，则 OF=1。C 语言整型用补码表示，imul 指令（带符号整数乘）使用的是补码乘法。补码一位乘法需要两个寄存器，按照题意，乘法器分为高 32 位和低 32 位，其中高 32 位存储在累加器 (A_cc_umulator, ACC) 中，低 32 位存储在乘商寄存器 (Multiplier-Quotient Register, MQ) 中，初始时 ACC 存储部分积，部分积初始为 0，MQ 存储 32 位的乘数。执行补码乘法结束后，高位和低位拼接起来为最终的 64 位乘积，但 int 只能表示 32 位，若不溢出，低 31 位为数值位，剩余高 33 位为 1 位符号位和 32 位符合扩展位，若乘积的高 33 位全 0 或全 1，即 32 位符合扩展位与符号位相同，则不溢出，OF=0；反之，若乘积的高 33 位为非全 0 或非全 1，即 32 位符合扩展位中存在某一位与符号位不同，则溢出，OF=1。
> 
> 第二问。编译器应该在 imul 指令后加一条 “溢出自陷指令”，使得 CPU 自动查询溢出标志 OF，当 OF=1 时调出 “溢出异常处理程序”。
> 
> 溢出自陷指令 (Overflow Trap Instruction) 是一种处理整数运算溢出的机器指令。它通常由处理器提供，并用于捕捉和处理算术运算中发生的溢出错误。当执行一条溢出自陷指令时，处理器会检测当前的算术运算结果是否发生了溢出。如果发生了溢出，处理器会触发一个异常或中断，将控制权转移到相应的异常处理程序中。溢出自陷指令的目的是提供一种机制，用于检测和处理数值运算的溢出。当进行加法、减法、乘法等算术运算时，如果结果超过了数据类型能够表示的范围，就会发生溢出。溢出可能导致错误的计算结果和无效的程序行为，因此通过溢出自陷指令可以及时地进行检测和处理。