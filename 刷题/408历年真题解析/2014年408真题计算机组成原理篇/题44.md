---
publish: true
tags: 
aliases: 
finished: true
title: 题44
created: "2024-11-21 06:44"
updated: "2024-11-21 07:40"
---
## 题44
### 题目
> [!question]+
> （12 分）
> 
> 某程序中有如下循环代码段 P：“`for (int i=0; i＜N; i++) sum += A[i];`”。假设编译时变量 sum 和 i 分别分配在寄存器 R1 和 R2 中。常量 N 在寄存器 R6 中，数组 A 的首地址在寄存器 R3 中。程序段 P 起始地址为 08048100H，对应的汇编代码和机器代码如下表所示。
> 
> 编号地址机器代码汇编代码注释
> $$\begin{array}{cccccc} \text{编号}&\text{地址}&\text{机器代码}&\text{汇编代码}&\text{注释}\\\hline 1&\text{08048100H}&\text{00022080H}&\text{loop: sll R4, R2, 2}&\text{(R2)<<2→R4}\\ 2&\text{08048104H}&\text{00083020H}&\text{add R4, R4, R3}&\text{(R4)+(R3)→R4}\\ 3&\text{08048108H}&\text{8C850000H}&\text{load R5, 0(R4)}&\text{((R4)+0)→R5}\\ 4&\text{0804810CH}&\text{00250820H}&\text{add R1, R1, R5}&\text{(R1)+(R5)→R1}\\ 5&\text{08048110H}&\text{20420001H}&\text{add R2, R2, 1}&\text{(R2)+1→R2}\\ 6&\text{08048114H}&\text{1446FFFAH}&\text{bne R2, R6, loop}&\text{if (R2)!=(R6) goto loop}\\ \end{array}$$
> 
> 执行上述代码的计算机 M 采用 32 位定长指令字，其中分支指令 bne 采用如下格式。
> 
> ![](https://pic1.zhimg.com/v2-c1cf10eb06ee4efef4f726d08edc4992_r.jpg)
> 
> Op 为操作码，Rs 和 Rd 为寄存器编号，OFFSET 为偏移量，用补码表示。请回答下列问题，并说明理由。
> 
> (1) M 的存储器编址单位是什么？
> 
> (2) 已知 sll 指令实现左移功能，数组 A 中每个元素占多少位？
> 
> (3) 题 44 表中 bne 指令的 OFFSET 字段的值是多少？已知 bne 指令采用相对寻址方式，当前 PC 内容为 bne 指令地址，通过分析题 44 表中指令地址和 bne 指令内容，推断出 bne 指令的转移目标地址计算公式。
> 
> (4) 若 M 采用如下 “按序发射、按序完成” 的 5 级指令流水线：IF（取指）、ID（译码及取数）、EXE（执行）、MEM（访存）、WB（写回寄存器），且硬件不采取任何转发措施，分支指令的执行均引起 3 个时钟周期阻塞，则 P 中那些指令的执行会由于数据相关而发生流水线阻塞？哪条指令的执行会发生控制冒险？为什么指令 1 的执行不会因为与指令 5 的数据相关而发生阻塞？
### 解
> [!done]+
> (1) 计算机 M 采用 32 位定长指令字，即一条指令占 4B，观察表中各指令的地址可知，每条指令的地址差为 4 个地址单位，指令 1 的地址为 08048100H，指令 2 的地址为 08048104H，指令长度和编址单位的比值为 08048104H-08048100H=4H=4，所以 M 的存储器编址单位是 4B/4=1B，即该计算机按字节编址。
> 
> (2) 根据题目条件，编译时变量 sum 和 i 分别分配在寄存器 R1 和 R2 中。常量 N 在寄存器 R6 中，数组 A 的首地址在寄存器 R3 中，数组中元素在内内存空间中连续存储。设初始时 sum = 0，N = 2，设 A 的首地址为 08050000H，A 数组元素类型大小为 x 字节，数组存放在堆空间中，数组元素在堆空间中按地址从小到大连续存储，所以 A[0] 首地址为 08050000H，A[1] 首地址为 08050000H+x，A[2] 首地址为 08050000H+2x，以此类推。红色表示指令执行后写入寄存器的值。模拟代码段 P 的指令执行过程如下：
> 
> 寄存器寄存器内容初始时第一次迭代执行指令后第一次迭代执行指令后第一次迭代执行指令后第一次迭代执行指令后第一次迭代执行指令后第一次迭代执行指令后第二次迭代执行指令后第二次迭代执行指令后第二次迭代执行指令后第二次迭代执行指令后第二次迭代执行指令后第二次迭代执行指令后首地址未知未知$\begin{array}{c} \text{寄存器}&\text{R1}&\text{R2}&\text{R3}&\text{R4}&\text{R5}&\text{R6}\\ \text{寄存器内容}&\text{sum}&\text{i}&\text{A首地址}&\text{未知}&\text{未知}&\text{N}\\ \hline \text{初始时}&\text{0}&\text{0}&\text{08050000H}&\text{-}&\text{-}&\text{2}\\ \text{第一次迭代执行指令1后}&\text{0}&\text{0}&\text{08050000H}&\color{red}{\text{0}}&\text{-}&\text{2}\\ \text{第一次迭代执行指令2后}&\text{0}&\text{0}&\text{08050000H}&\color{red}{\text{08050000H}}&\text{-}&\text{2}\\ \text{第一次迭代执行指令3后}&\text{0}&\text{0}&\text{08050000H}&\text{08050000H}&\color{red}{\text{A[0]}}&\text{2}\\ \text{第一次迭代执行指令4后}&\color{red}{\text{A[0]}}&\text{0}&\text{08050000H}&\text{08050000H}&{\text{A[0]}}&\text{2}\\ \text{第一次迭代执行指令5后}&\text{A[0]}&\color{red}{\text{1}}&\text{08050000H}&\text{08050000H}&{\text{A[0]}}&\text{2}\\ \text{第一次迭代执行指令6后}&\text{A[0]}&\text{1}&\text{08050000H}&\text{08050000H}&{\text{A[0]}}&\text{2}\\ \text{第二次迭代执行指令1后}&\text{A[0]}&\text{1}&\text{08050000H}&\color{red}{\text{4}}&{\text{A[0]}}&\text{2}\\ \text{第二次迭代执行指令2后}&\text{A[0]}&\text{1}&\text{08050000H}&\color{red}{\text{08050004H}}&{\text{A[0]}}&\text{2}\\ \text{第二次迭代执行指令3后}&\text{A[0]}&\text{1}&\text{08050000H}&\text{08050004H}&\color{red}{\text{A[1]}}&\text{2}\\ \text{第二次迭代执行指令4后}&\color{red}{\text{A[0]+A[1]}}&\text{1}&\text{08050000H}&\text{08050004H}&\text{A[1]}&\text{2}\\ \text{第二次迭代执行指令5后}&\text{A[0]+A[1]}&\color{red}{\text{2}}&\text{08050000H}&\text{08050004H}&\text{A[1]}&\text{2}\\ \text{第二次迭代执行指令6后}&\text{A[0]+A[1]}&\text{2}&\text{08050000H}&\text{08050004H}&\text{A[1]}&\text{2}\\ \end{array}$
> 
> 通过该过程的模拟，推出 R4 的内容为 A[i] 首地址或 A[i] 首地址距离 A 首地址的偏移，R5 的内容为 A[i] 的值，根据 R4 的 A[i] 首地址的计算式，即 首地址首地址$A[i]\text{首地址} = A\text{首地址}+4i$ ，等价于 首地址首地址$A[i]\text{首地址} = A\text{首地址}+xi$ ，解得 $x=4$ ，即 A 数组元素类型大小为 4 字节。数组 A 中每个元素占 4B=32bit。
> 
> 这个推导过程非常麻烦，如果考场上没时间进行推理，由于这里是进行加法运算，常用的数据类型有 char、short、int、float 和 double，char 用于字符串，剩余均可用于四则运算，short 和 double 在 408 中出现通常与类型转换相关，只有 int 和 float 最常考，所以直接猜 A 中元素类型为 int 或 float，在 32 位或 64 位计算机中，int 或 float 大小为 4B，数组 A 中每个元素占 4B=32bit。
> 
> (3) 第一问。由表可知，bne (branch when not equal) 指令的机器代码为 1446FFFAH，根据题目给出的指令格式，低 16 位的为 OFFSET 字段，所以该指令的 OFFSET 内容为 FFFAH，用补码表示，[OFFSET] 补 = FFFAH=1111 1111 1111 1010B，[OFFSET] 原 = 1000 0000 0000 0110B= -6。
> 
> 第二问。指令跳转 PC 自增一个指令字长的字长数，本题为 4，从指令 6 的地址跳转到指令 1 的地址，08048100H = 08048114H + 4H + k×OFFSET，所以 ×OFFSET = -18H=-16-8=-24，OFFSET=-6，所以 k=4，bne 指令的转移目标地址计算公式为 (PC)+4+4×OFFSET。
> 
> 本题为 2013 年题 44 的变体，将该题的转移目标地址计算公式 (PC)+2+2×OFFSET 中的 2 修改为 4，得到 (PC)+4+4×OFFSET，即为这一问的答案。
> 
> (4) 第一问。因为指令 2、3、4、6 都与各自前一条指令发生数据相关，所以由于数据相关而发生阻塞的指令为指令 2、3、4、6。
> 
> 数据冒险：在一个程序中，下一条指令会用到当前指令计算的结果，此时这两条指令发生数据冲突。指令 1 和指令 2，指令 2 和指令 3，指令 3 和指令 4，指令 5 和指令 6 均为写后读相关。由于 M 采用如下 “按序发射、按序完成” 的 5 级指令流水线，且硬件不采取任何转发措施，对于写后读相关，当前指令将数据写入寄存器后，下一条指令才能从该寄存器中读取数据；否则，先读后写，读取到的就是错误（旧）数据。因此只能进行阻塞，需要阻塞 3 个时钟周期。所以由于数据相关而发生阻塞的指令为指令 2、3、4、6。
> 
> 第二问。指令 6 进行分支预测，会发生控制冒险。
> 
> 控制冒险：指令通常是顺序执行，但是遇到改变指令执行顺序的情况，例如执行转移、调用或返回指令时，会改变 PC 值，从而造成断流，引起控制冒险。指令 6 进行分支预测，判断结果为真就跳转指令 1 继续执行，指令 6 和指令 1 存在控制相关。由于 M 采用如下 “按序发射、按序完成” 的 5 级指令流水线，若不采用分支预测或其他任何优化方法，则对于分支预测指令，当前指令执行并访存后，下一条指令才能开始执行，因此只能进行阻塞，需要阻塞 3 个时钟周期。指令 6 进行分支预测，会发生控制冒险。
> 
> 第三问。当前循环的指令 5 与下次循环的指令 1 虽然有数据相关，但由于
> 
> 1. 指令 5 和指令 6 存在数据相关。由于 M 采用如下 “按序发射、按序完成” 的 5 级指令流水线，且硬件不采取任何转发措施，因此引起 3 个时钟周期阻塞；
> 2. 指令 6 是分支指令，指令 6 和指令 1 存在控制相关。分支指令的执行均引起 3 个时钟周期阻塞。
> 
> 因而消除了该数据相关。
> 
> 用 NOP 指令进行阻塞，模拟指令流水线如下：
> 
> ![](https://pic4.zhimg.com/v2-8399f70b1e000c7fd9737702a001ff41_r.jpg)