---
publish: true
tags: 
aliases: 
finished: true
title: 题06
created: "2024-11-21 07:26"
updated: "2024-11-21 07:40"
---
## 题06
### 题目
> [!question]+
> 修改递归方式实现图的深度优先搜索（DFS）算法，将输出（访问）顶点信息的语句移到退出递归前（即执行输出语句后立刻退出递归）。采用修改后的算法遍历有向无环图 G，若输出结果中包含 G 中全部顶点，则输出的顶点序列是 G 的（ ）。
> 
> A. 拓扑有序序列
> 
> B. 逆拓扑有序序列
> 
> C. 广度优先搜索序列
> 
> D. 深度优先搜索序列
### 解
> [!done]+
> 这道题的表述非常复杂，其实意思就是先进行递归调用，再进行输出。
> 
> **方法一：类比**
> 
> 由于这里是选择题，我们联想一下，我们没有接触过这样的例子呢？很显然，二叉树的后序遍历。
> 
> 二叉树又恰好是无向无环图的一个特例，下面开始观察二叉树的后序遍历。二叉树后序遍历伪代码如下：
> 
> ```cpp
> POSTORDER(x) 
>     if x ≠ NIL
>         POSTORDER(x.left)
>         POSTORDER(x.right)
>         print x.key
> 
> PRINT-BINARY-TREE(T)
>     POSTORDER(T.root)
> ```
> 
> 二叉树后序遍历的输出顺序是 “左右根”。即先输出叶结点，再输出根结点。输出顺序是自底向上的，也是逆拓扑有序序列。其它的明显不对哦，在二叉树中，前序遍历序列是一种深度优先搜索序列，层序遍历序列是一种广度优先搜索序列，拓扑排序是一个自顶向下的遍历。逆拓扑排序意思是反过来的拓扑排序。
> 
> 本题选 **B**。
> 
> **方法二：推理**
> 
> 当然我们也可以严格分析，设有一条 u→v 的有向边，递归需要用到递归栈，按照题意，先输出栈顶的，再输出栈底的，所以先输出 v，再输出 u，即先输出出度为 0 的结点 v，此时让 u 的出度减一变为 0，再输出 u，正好和拓扑排序反了过来，拓扑排序是寻找入度为 0 的点输出。
> 
> 本题选 **B**。