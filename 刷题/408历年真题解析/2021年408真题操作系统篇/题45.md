---
publish: true
tags: 
aliases: 
finished: true
title: 题45
created: "2024-11-21 07:26"
updated: "2024-11-21 07:40"
---
## 题45
### 题目
> [!question]+
> （7 分）
> 
> 下表给出了整型信号量 S 的 wait() 和 signal() 操作的功能描述，以及采用开 / 关中断指令实现信号量操作互斥的两种方法。
> 
> ```cpp
> // 功能描述
> Semaphore S;
> wait(S){
>     while(S <= 0);
>     S = S-1;
> }
> signal(S){
>     S = S+1;
> }
> 
> // 方法1
> Semaphore S;
> wait(S){
>     关中断;
>     while(S <= 0);
>     S = S-1;
>     开中断;
> }
> signal(S){
>     关中断;
>     S = S+1;
>     开中断;
> }
> 
> // 方法2
> Semaphore S;
> wait(S){
>     关中断;
>     while(S <= 0){
>         开中断;
>         关中断;
>     }
>     S = S-1;
>     开中断;
> }
> signal(S){
>     关中断;
>     S = S+1;
>     开中断;
> }
> ```
> 
> 请回答下列问题。
> 
> (1) 为什么在 wait() 和 signal() 操作中对信号量 S 的访问必须互斥执行？
> 
> (2) 分别说明方法 1 和方法 2 是否正确。若不正确，请说明理由。
> 
> (3) 用户程序能否使用开 / 关中断指令实现临界区互斥？为什么？
### 解
> [!done]+
> (1) 因为信号量 S 是能够被多个进程共享的临界资源，多个进程都可以通过 wait() 和 signal() 对 S 进行读、写操作。所以，在 wait() 和 signal() 操作中对 S 的访问必须是互斥的。
> 
> (2) 方法 1 是错误的。在 wait() 中，当 S<=0 时，[[关中断]]后，其他进程无法修改 S 的值，while 语句陷人死循环。方法 2 是正确的。
> 
> (3) 用户程序不能使用开 / 关中断指令实现临界区互斥。因为开中断和关中断指令都是特权指令。