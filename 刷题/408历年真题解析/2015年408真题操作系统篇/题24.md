---
publish: true
tags: 
aliases: 
finished: true
title: 题24
created: "2024-11-21 06:44"
updated: "2024-11-21 07:40"
---
## 题24
### 题目
> [!question]+
> 假定下列指令已装入指令寄存器，则执行时不可能导致 CPU 从用户态变为内核态（系统态）的是（ ）。
> 
> A. DIV R0, R1 ；(R0) / (R1) → R0
> 
> B. INT n ；产生软中断
> 
> C. NOT R0 ；寄存器 R0 的内容取非
> 
> D. MOV R0, addr ；把地址 addr 处的内存数据放入寄存器 R0 中
### 解
> [!done]+
> 用户态和内核态是操作系统中的两种不同特权级别，用于区分用户程序和操作系统核心的执行权限。在用户态，程序只能访问受限资源，并受到操作系统的保护。而在内核态，操作系统具有更高的权限，可以执行敏感操作和访问系统资源。
> 
> A 错误。指令 DIV R0, R1 执行的是除法操作，若除数 (R1) 为 0，则产生异常，需要操作系统在内核态进行处理，会导致 CPU 从用户态变为内核态。
> 
> B 错误。指令 INT n 产生软中断，会触发相应的的中断处理程序，需要操作系统在内核态进行处理，会导致 CPU 从用户态变为内核态。
> 
> C 正确。指令 NOT R0 为将寄存器 R0 的内容取非，这是一个简单的逻辑操作，位运算即可实现，只需要在用户态进行处理，不可能导致 CPU 从用户态变为内核态。
> 
> D 错误。指令 MOV R0, addr 将内存数据加载到寄存器中。虚拟地址空间包括内核与用户空间。其中内核空间供内核使用，用户空间供用户程序使用。在用户态下，应用程序无法直接访问内核空间的内存。如果 addr 所指向的内存地址是用户空间的地址，那么执行 MOV R0, addr 是在用户态进行的，不会导致 CPU 从用户态变为内核态。然而，如果 addr 所指向的内存地址是内核空间的地址，或者是特定的内存映射区域（例如 I/O 地址空间），那么执行 MOV R0, addr 可能需要切换到内核态。在这种情况下，操作系统需要处理这个指令，将 addr 所指向的数据加载到 R0 寄存器中，因此 CPU 可能会切换到内核态执行指令，并在内核态下访问内核空间的内存。
> 
> 本题选 C。
> 
> **_拓展_**
> 
> Linux 上的 32 位进程的虚拟地址空间通常被分为以下几部分：
> 
> 1. 用户空间：用户空间是进程可直接访问的部分，它包含了进程的代码段、数据段、堆、栈等。对于 32 位的进程，用户空间的大小通常是 3GB。这 3GB（地址范围 0x00000000 ~ 0xBFFFFFFF）是进程可用于用户程序和数据的地址范围，但并非所有的地址都是完全可用的，其中一部分是保留给操作系统和共享库使用的。
> 2. 内核空间：内核空间是操作系统内核的私有地址空间，用于存放操作系统内核代码、数据结构和设备驱动程序等。在 32 位的 Linux 上，内核空间的大小通常为 1GB（地址范围 0xC0000000 ~ 0xFFFFFFFF），它是所有进程共享的部分。进程无法直接访问内核空间，必须通过系统调用向内核发起请求，由内核代表进程执行所需的操作。
> 3. 内核空间的高端：内核空间的高端区域是留给操作系统内核使用的，例如页表结构、内核堆栈等。这个区域位于内核空间的最高地址（地址范围 0xFF800000 ~ 0xFFFFFFFF），进程无法直接访问。
> 
> Linux 的虚拟地址空间提供了进程隔离和内存保护的机制，使每个进程都以为自己在独立的内存空间中运行。实际的物理内存映射到不同的虚拟地址空间中，由操作系统的内存管理单元 (Memory Management Unit, MMU) 负责地址映射和保护。
> 
> 更多内容可阅读 [vito：虚拟地址空间（Linux 操作系统）](https://zhuanlan.zhihu.com/p/655241681)。