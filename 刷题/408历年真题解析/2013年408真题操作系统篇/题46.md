---
publish: true
tags: 
aliases: 
finished: true
title: 题46
created: "2024-11-21 06:42"
updated: "2024-11-21 07:40"
---
## 题46
### 题目
> [!question]+
> （8 分）
> 
> 某计算机主存按字节编址，逻辑地址和物理地址都是 32 位，页表项大小为 4 字节。请回答下列问题。
> 
> (1) 若使用一级页表的分页存储管理方式，逻辑地址结构为：
> 
> $$\begin{array}{|c|}\hline \text{页号（20 位）}&\text{页内偏移量（12 位）}\\\hline \end{array}$$
> 
> 则页的大小是多少字节？页表最大占用多少字节？
> 
> (2) 若使用二级页表的分页存储管理方式，逻辑地址结构为：
> 
> $$\begin{array}{|c|}\hline \text{页目录号（10 位）}&\text{页表索引（10 位）}&\text{页内偏移量（12 位） }\\\hline \end{array}$$
> 
> 设逻辑地址为 LA，请分别给出其对应的页目录号和页表索引的表达式。
> 
> (3) 采用 (1) 中的分页存储管理方式，一个代码段起始逻辑地址为 0000 8000H，其长度为 8KB，被装载到从物理地址 0090 0000H 开始的连续主存空间中。页表从主存 0020 0000H 开始的物理地址处连续存放，如下图所示（地址大小自下向上递增）。请计算出该代码段对应的两个页表项的物理地址、这两个页表项中的页框号以及代码页面 2 的起始物理地址。
> 
> ![](https://img.hwenyi.tech/202412030239755.webp)
> 
> 
> ![](https://img.hwenyi.tech/202412030239755.webp)
### 解
> [!done]+
> (1) 第一问，因为该计算机主存按字节编址，页内偏移量是 12 位，所以页大小是 $2^{12}$ ×1B=4KB。第二问，页号占 20 位，说明最多有 $2^{20}$ 个页面，一个页表项占 4B，一级页表最大占用 $2^{20}$ ×4B=4MB。
> 
> (2) 我们通过观察对二进制串进行分割可以直接提取目标字段，但计算机只能通过运算获取。由于为了节约内存，内存地址存储为由比特位构成的整型，而不是由字符型构成字符串，所以 LA 中内容无法通过字符串分割获取，必须通过整型的运算获取。这里用 C 语言进行模拟。二级页表的分页存储管理方式逻辑地址占 10+10+12=32 位，恰好用一个 32 位的 unsigned int 表示。
> 
> ![](https://img.hwenyi.tech/202412030239756.webp)
> 
> **方法一：位运算**
> 
> 页目录号占高 10 位，第一步通过逻辑右移移动到低 10 位，同时去除了比页目录号位数低的内容，逻辑地址为无符号数，右移 22 位后得 ((unsigned int)(LA)) >> 22（C 语言中右移运算为算术右移，需要先将 LA 强转为无符号整型），第二步需要用掩码 (mask) 截取低 10 位内容，掩码为 1111111111B=0x3FF，进行按位与操作，得到最终表达式 (((unsigned int)(LA)) >> 22) & 0x3FF。由于此时有效数值位全在低 10 位，其它有效数值位均已通过右移运算被过滤掉，也可无需用掩码提取，得到最终 C 语言表达式 (((unsigned int)(LA)) >> 22)。结果如图 (b) 所示。
> 
> 页表索引占中间 10 位，第一步通过逻辑右移移动到低 10 位，同时去除了比页表索引位数低的内容，逻辑地址为无符号数，右移 12 位后得 ((unsigned int)(LA)) >> 12（C 语言中右移运算为算术右移，需要先将 LA 强转为无符号整型），第二步需要用掩码截取低 10 位内容（由于剩余有效数值既包含页目录号和页表索引），掩码为 1111111111B=0x3FF，进行按位与操作，得到最终表达式 (((unsigned int)(LA)) >> 12) & 0x3FF。当然，先用掩码进行按位与操作然后进行逻辑右移操作也是可以的，掩码为 0000 0000 0011 1111 1111 0000 0000 0000B=3FF000H，然后右移 12 位，得到最终表达式 (LA & 0x3FF000) >> 12。结果如图 (c) 所示。
> 
> **方法二：除法运算和模运算**
> 
> 页目录号占高 10 位，第一步通过除法运算移动到低 10 位，同时去除了比页目录号位数低的内容，逻辑地址为无符号数，除数为 $2^{22}$ =100 0000 0000 0000 0000 0000B = 400000H，得到 ((unsigned int)(LA)) / 0x400000，第二步需要截取低 10 位内容，进行模运算，模数为 $2^{12}$ =100 0000 0000B = 400H，得到最终表达式 (((unsigned int)(LA)) / 0x400000) % 0x400。结果如图 (b) 所示。
> 
> 页表索引占中间 10 位，第一步通过除法运算移动到低 10 位，同时去除了比页表索引位数低的内容，逻辑地址为无符号数，除数为 $2^{12}$ =1 0000 0000 0000B = 1000H，得到 ((unsigned int)(LA)；第二步需要截取低 10 位内容，进行模运算，模数为 100 0000 0000B = 400H，得到最终表达式 (((unsigned int)(LA)) / 0x1000) % 0x400。当然，也可以第一步通过模运算去除比页表索引位数高的内容，模数为 $2^{22}$ =100 0000 0000 0000 0000 0000B = 400000H，得到 ((unsigned int)(LA)) % 0x400000；第二步通过除法移动到低 10 位，同时去除了比页表索引位数低的内容，除数为 1 0000 0000 0000B = 1000H，得到最终表达式 (((unsigned int)(LA)) % 0x400000) / 0x1000。结果如图 (c) 所示。
> 
> 显然位运算比除法运算和模运算更加高效。
> 
> (3) 因为采用 (1) 中的分页存储管理方式，根据问题 (1) 给出的一级页表逻辑地址格式，代码起始逻辑地址为 $\underbrace{0000 8}_{\text{页号}}\underbrace{000}_{\text{页内偏移量}}$ H ，页内偏移量为 0，代码长度为 8KB，根据问题 (1) 的结论，一个页面占 4KB，恰好需要连续 8KB/4KB = 2 个页面存放。页表起始地址为 0020 0000H，一个页表项占 4B，该计算机主存按字节编址，一个页表项占 4H 个地址单元。页表项的物理地址 = 页表起始地址 + 页号 × 页表项的字节数。
> 
> 页面 1 的逻辑地址为 $\underbrace{0000 8}_{\text{页号}}\underbrace{000}_{\text{页内偏移量}}$ H，页号为 8H=8，对应页表中的页表项 8，得到页面 1 的页表项的物理地址 = 0020 0000H+8×4H=0020 0020H。页面 2 的逻辑地址为 $\underbrace{0000 9}_{\text{页号}}\underbrace{000}_{\text{页内偏移量}}$ H，页号为 9H=9，对应页表中的页表项 9，得到页面 2 的页表项的物理地址 = 0020 0000H+9×4H=0020 0024H。
> 
> 该代码被主存空间起始物理地址为 $\underbrace{0090 0}_{\text{页框号}}\underbrace{000}_{\text{页内偏移量}}$ H ，页内偏移量为 0，连续存储，同样地，恰好需要连续两个页框存放，代码页面 1 的物理地址为 $\underbrace{0090 0}_{\text{页框号}}\underbrace{000}_{\text{页内偏移量}}$ H，代码页面 2 的物理地址为 $\underbrace{0090 1}_{\text{页框号}}\underbrace{000}_{\text{页内偏移量}}$ H。
> 
> 综上，页框号 1 是 00900H，页框号 2 是 00901H，物理地址 1 是 0020 0020H，物理地址 2 是 0020 0024H，物理地址 3 是 0090 1000H。