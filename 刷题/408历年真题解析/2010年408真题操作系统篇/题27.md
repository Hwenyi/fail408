---
publish: true
tags: 
aliases: 
finished: true
title: 题27
created: "2024-11-21 06:39"
updated: "2024-11-21 07:40"
---
## 题27
### 题目
> [!question]+
> 进程 P0 和 P1 的共享变量定义及其初值为
> 
> ```cpp
> boolean flag[2];
> int turn = 0;
> flag[0] = FALSE; 
> flag[1] = FALSE;
> ```
> 
> 若进程 P0 和 P1 访问临界资源的类 C 伪代码实现如下：
> 
> ```cpp
> void P0() { //进程P0
>     while (TRUE) {
>         flag[0] = TRUE;
>         turn = 1;
>         while (flag[1] && (turn == 1));
>         临界区;
>         flag[0] = FALSE;
>     }
> }
> 
> void P1() { //进程P1
>     while (TRUE) {
>         flag[1] = TRUE;
>         turn = 0;
>         while (flag[0] && (turn == 0));
>         临界区;
>         flag[1] = FALSE;
>     }
> }
> ```
> 
> 则并发执行进程 P0 和 P1 时产生的情形是（ ）。
> 
> A. 不能保证进程互斥进入临界区，会出现 “饥饿” 现象
> 
> B. 不能保证进程互斥进入临界区，不会出现 “饥饿” 现象
> 
> C. 能保证进程互斥进入临界区，会出现 “饥饿” 现象
> 
> D. 能保证进程互斥进入临界区，不会出现 “饥饿” 现象
### 解
> [!done]+
> **方法一：Peterson 算法**
> 
> 本题考察进程间通信与 Peterson 算法。算法实现互斥的主要思想在于设置了一个 turn 变量用于进程间的互相谦让。如果进程 P0 试图访问临界资源，则 flag[0]=true 表示 P0 希望访问。此时如果进程 P1 还未试图访问临界资源，则 flag[1] 在进程上一次访问完临界资源退出临界区后已设置为 false。所以进程 P0 在直线循环判断条件时，第一个条件不满足，进程 P0 可以正常进入临界区，且满足互斥条件。需要考虑的是两个进程同时试图访问临界资源的情况。注意 turn 变量的含义：当某进程试图访问时，首先设置自己的 flag 变量为 true，表示希望访问；但又设置 turn 变量为对方的进程编号，表示谦让。因为在循环判断条件中 turn 变量不是自己的编号时就循环等待。虽然两个进程会互相谦让一番，但是这不会造成饥饿的局面，因为 turn 变量会有一个最终值，所以必定有进程可以结束循环进入临界区。实际情况是，先作出谦让的进程先进入临界区，后作出谦让的进程则需要循环等待。其实这里可以想象为两个人进门，每个人进门前都会和对方客套一句 “您走先”。如果进门时没别人，就当和空气说句废话，然后大步登门入室；如果两人同时进门，就互相 “谦让”，但各自只客套一次，所以先客套的人请完对方，就等着对方请自己，然后光明正大进门。
> 
> Peterson 算法遵循空闲让进、忙则等待、有限等待这三个原则，未遵循让权等待原则，暂时无法进入临界区的进程会占用 CPU 并执行拦截进入临界区的 while 循环导致忙等。
> 
> 本题选 D。
> 
> **方法二：模拟**
> 
> 如果没有看出这是一个 Peterson 算法，那么可以用更通用的方法解决该问题，即直接观察代码进行模拟。
> 
> 初始时 P0 和 P1 尚未执行，均未进入临界区，如图 (a) 所示。
> 
> ![](https://pica.zhimg.com/v2-db4f81ffcecc288a3c1a5c54d8d621c4_r.jpg)
> 
> 我们先考虑 P0 和 P1 都无法进入临界区的情况，即两个拦截进入临界区 while 循环的判断条件均成立，则 (flag[1] && (turn == 1)) 和 (flag[0] && (turn == 0)) 均为真成立，显然 turn == 1 和 turn == 0 不可能同时成立，因此这种情况不可能出现；同理，P0 和 P1 同时进入临界区也不可能。进程 P0 和进程 P1 至少有一个能进入临界区。很明显，进程 P0 和进程 P1 的代码具有轮换对称性，不失一般性，假设此时 P0 能够进入临界区，此时 flag[0] = TRUE; turn = 1; 一定已经执行，有 flag[0] == TRUE 且 turn == 1，观察进程 P1 在进入临界区前代码为 flag[1] = TRUE; turn = 0; 不会修改 flag[0]。因为 P0 能够进入临界区，则有 flag[1] && (turn == 1) 为假，即 flag[1] == FLASE 或 turn != 1 为真，只要进程 P1 执行 turn=0; 即可满足条件，此时 P0 进入临界区，P1 未进入临界区，如图 (b) 所示。
> 
> ![](https://picx.zhimg.com/v2-78f9bc860f036daf81058f382fb12641_r.jpg)
> 
> P0 访问临界区结束后，设置 flag[0] = FALSE，此时拦截进程 P1 进入临界区的 while 循环判断条件 flag[0] && (turn == 0) 为真不成立，进程 P1 能够进入临界区（此前已经设置 flag[1] = TRUE）。如果进程 P0 想在 P1 在访问临界区时重新访问临界区，必须满足拦截 P0 进入临界区 while 循环判断条件 flag[1] && (turn == 1) 为真不成立，在进行拦截 P0 进入临界区的 while 循环判断前需要重新执行 flag[0] = TRUE; turn = 1; 加上此前进程 P1 设置的 flag[1] = TRUE，此时拦截进程 P0 进入临界区的 while 循环判断条件 flag[0] && (turn == 0) 为真成立，P0 无法进入临界区，如图 (c) 所示。
> 
> ![](https://pic4.zhimg.com/v2-b916eebaf5d82cd2969d651eda4ede01_r.jpg)
> 
> 该算法实现了进程 P0 和进程 P1 互斥访问临界区。
> 
> 本题选 D。