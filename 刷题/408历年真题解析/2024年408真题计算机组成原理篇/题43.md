---
publish: true
tags: 
aliases: 
finished: true
title: 题43
created: "2024-11-21 07:37"
updated: "2024-11-21 07:40"
---
## 题43
### 题目
> [!question]+
> （本题 13 分）
> 
> 假定计算机 M 字长 32 位，按字节编址，采用 32 位定长指令字。指令 add、slli 和 lw 的格式、编码和功能说明如题 43 图 (a) 所示。
> 
> ![](https://pic3.zhimg.com/v2-b687247f32154cd73e081199dab9e708_r.jpg)
> 
> 其中，R[x] 表示通用寄存器 x 的内容，M[x] 表示地址为 x 的存储单元内存，shamt 为 移位位数，imm 为补码表示的偏移量。题 43 图 (b) 给出了计算机 M 的部分数据通路及控制信号（用带箭头虚线表示），其中，A 和 B 分别表示从通用寄存器 rs1 和 rs2 中读出的内容；IR[31:20] 表示指令寄存器中的高 12 位；控制信号 Ext 为 0、1 时扩展器分别实现零扩展、符号扩展，ALUctr 为 000、001、010 时 ALU 分别实现加、减、逻辑左移运算。
> 
> ![](https://pic2.zhimg.com/v2-501c60f432e3f8d738fde0001ff9eb51_r.jpg)
> 
> 请回答下列问题。
> 
> (1) 计算机 M 最多有几个通用寄存器？为什么 shamt 占 5 位？（2 分）
> 
> (2) 执行 add 指令时，控制信号 ALUBsrc 的取值应是什么？若 rs1 和 rs2 寄存器内容分别是 8765 4321 H 和 9876 5432 H，则 add 指令执行后，ALU 输出端 F、OF 和 CF 的结果分别是什么？若该 add 指令处理的是无符号整数，则应该根据哪个标志位判断是否溢出？（5 分）
> 
> (3) 执行 slli 指令时，控制信号 Ext 的取值可以是 0 也可以是 1，为什么？（2 分）
> 
> (4) 执行 lw 指令时，控制信号 Ext、ALUctr 的取值分别是什么？（2 分）
> 
> (5) 若一条指令的机器码是 A040 A103 H，则该指令一定是 lw 指令，为什么？若执行该指令时，R[01H] = FFFF A2D0 H，则所读取数据的存储地址是什么？（2 分）
### 解
> [!done]+
> (1) 第一问。最多有 32 个通用寄存器。
> 
> 观察题 43 图 (a)，通用寄存器 rs1 占 IR[19 : 15] 共计 5 位，通用寄存器 rs2 占 IR[24 : 20] 共计 5 位，通用寄存器 rd 占 IR[11 : 7] 共计 5 位，可以推出通用寄存器占 5 位，5 位能表示 $2^5=32$ 个不同的整数，也就能编号 32 个不同的寄存器，因此最多有 32 个通用寄存器。
> 
> 第二问。M 字长为 32 位，故通用寄存器宽度为 32 位，因此 shamt 字段占 $\log_2 32 = 5$ 位。
> 
> 根据题目条件，计算机 M 字长 32 位，一般情况下，通用寄存器的位数与计算机字长一致，所以通用寄存器的位数为 32。shamt 在指令 slli 的指令功能说明 “R[rd]←R[rs1]<<shamt” 中出现，显然指令 slli 实现的是逻辑左移功能，shamt 占 IR[24 : 20] 共计 5 位，shamt 表示移位位数，可以表示的整数范围为 0 ~ $2^5-1$ ，即 0 ~ 31。已知通用寄存器的位数为 32，对于 32 位机器数，要实现逻辑左移，能够左移的位数范围恰为 0 ~ 31，超出该范围会导致所有有效位丢失。因此，由 M 字长为 32 位可以推出 shamt 字段占 $\log_2 32 = 5$ 位。
> 
> (2) 第一问。控制信号 ALUBsrc = 0。
> 
> 根据题 43 图 (b)，控制信号 ALUBsrc 控制多路选择器 MUX，当 ALUBsrc = 0 时，选择 B 这个分支为输入，当 ALUBsrc = 1 时，选择 IR[31 : 20] 经过扩展器这个分支为输入。根据题目条件，A 和 B 分别表示从通用寄存器 rs1 和 rs2 中读出的内容。又根据题 43 图 (a)，add 指令的功能说明为 “R[rd]←R[rs1]+R[rs2]”，推出 add 指令的功能就是将 A 和 B 相加。根据题 43 图 (b)，ALU 已经有一个输入为 A，推出另外一个输入为 B，多路选择器 MUX 的输出为 ALU 的另一个输入，当且仅当 ALUBsrc = 0 时，MUX 的输出才能是 B。因此，控制信号 ALUBsrc = 0。
> 
> 第二问。F = 1FDB 9753 H；OF = 1；CF = 1。
> 
> 若 rs1 和 rs2 寄存器内容分别是 8765 4321 H 和 9876 5432 H，执行 add 指令，有 A = 8765 4321 H 和 B = 9876 5432 H，手动计算 A + B = 8765 4321 H + 9876 5432 H = (1) 1FDB 9753 H，得到 F = 1FDB 9753 H。
> 
> OF (Overflow Flag) 溢出标志位，用于指示有符号运算是否发生溢出。当有符号操作结果超出了有符号数的表示范围时，OF 位会被设置为 1，表示溢出。否则，OF 位将被设置为 0。采用二进制计算，对于有符号整数加法，采用一位符号位判断溢出，只有在正数加正数和负数加负数两种情况下才可能出现溢出，符号不同的两个数相加不会出现溢出。计算 A + B = 8765 4321 H + 9876 5432 H = 1000 0111 0110 0101 0100 0011 0010 0001 B + 1001 1000 0111 0110 0101 0100 0011 0010 B = (1) 0001 1111 1101 1011 1001 0111 0101 0011 B。A 符号位为 1，B 符号位为 1，相加结果符号位为 0，显然两个负数相加得到一个正数。发生溢出。因此 OF = 1。也可以扩充一位符号位采用双符号位判断是否溢出，这里省略推理步骤。
> 
> CF (Carry Flag) 进位标志位，用于指示无符号操作中的进位或借位情况。当无符号操作最高有效位外的更高位产生进位时，CF 位会被设置为 1。否则，CF 位将被设置为 0。在加法中，若两个无符号数相加的结果发生溢出，则 CF = 1，表示有进位发生，否则 CF = 0，表示没有进位发生。若两个无符号数相减时，减数大于被减数，则 CF = 1，表示有借位发生，否则 CF = 0，表示没有借位发生。显然这计算结果最高有效位发生进位，因此 CF = 1。
> 
> 第三问。根据 CF 判断是否溢出。
> 
> 若该 add 指令处理的是无符号整数，OF 用于指示有符号运算是否发生溢出，而 CF 用于指示无符号操作中的进位或借位情况，因此根据 CF 判断是否溢出。
> 
> (3) 因为 slli 指令的移位位数 shamt 只使用 IR[31 : 20] 中的低 5 位 IR[24 : 20]，与高位 IR[31 : 25] 及扩展出来的位无关，故 Ext 取值可以是 0 也可以是 1。
> 
> 根据题 43 图 (b) 和题目条件，控制信号 Ext 作用于扩展器，控制信号 Ext 为 0、1 时扩展器分别实现零扩展、符号扩展，扩展对象为 IR[31 : 20]，IR[31 : 20] 的最高位为 0，无论进行零扩展还是符号扩展，扩展出来的更高位都是 0，因此 Ext 取值可以是 0 也可以是 1。
> 
> (4) Ext = 1；ALUctr = 000。
> 
> 根据题 43 图 (a) 中的 lw 指令结构，imm 占 IR[31 : 20]，根据题 43 图 (b)，扩展器对 IR[31 : 20] 进行扩展，因此在 lw 指令中，是对 imm 进行扩展，根据题目条件，imm 为补码表示的偏移量。补码是有符号整数的一种表示方式，对补码进行扩展必须为符号扩展。控制信号 Ext 作用于扩展器，控制信号 Ext 为 0、1 时扩展器分别实现零扩展、符号扩展，所以 Ext = 1。
> 
> 根据题 43 图 (a) 中的 lw 指令功能说明，“R[rd]←M[R[rs1]+imm]”，再根据题 43 图 (b) 和题目条件，A 表示从通用寄存器 rs1 内容，即 A 对应指令中的 R[rs1]，和 imm 执行的是加法运算。ALUctr 为 000、001、010 时 ALU 分别实现加、减、逻辑左移运算。所以 ALUctr = 000。
> 
> (5) 第一问。因为 A040 A103 H = 1010 0000 0100 0000 1010 0001 0000 0011 B，根据指令格式中 IR[6 : 0] = 000011 B，IR[14 : 12] = 010 B，符合题 43 图 (a) 中 lw 指令的结构，可以判定该指令是 lw 指令。
> 
> 第二问。lw 指令所读取的存储地址为 FFFF 9CD4 H。
> 
> 指令 A040 A103 H 的 IR[31 : 20] = A04 H，为 imm 值，imm 为补码表示的偏移量。若执行该指令时，R[01H] = FFFF A2D0 H，即 R[rs1] = FFFF A2D0 H，imm = A04 H = 1010 0000 0100 B，imm 符号位为 1，符号位扩展高位补 1，补齐至 32 位，即高位补 20 个 1 后（即 5 个十六进制 F）得到 imm = FFFF FA04 H，lw 指令功能执行 “R[rd]←M[R[rs1]+imm]”，R[rs1] + imm = FFFF A2D0 H + FFFF FA04 H = (1) FFFF 9CD4 H。因此 lw 指令所读取的存储地址为 FFFF 9CD4 H。