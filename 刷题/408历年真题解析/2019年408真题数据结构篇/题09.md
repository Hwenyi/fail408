---
publish: true
tags: 
aliases: 
finished: true
title: 题09
created: "2024-11-21 07:25"
updated: "2024-11-21 07:40"
---
## 题09
### 题目
> [!question]+
> 设主串 T = "abaabaabcabaabc"，模式串 S = "abaabc"，采用 KMP 算法进行模式匹配，到匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是（ ）。
> 
> A. 9
> 
> B. 10
> 
> C. 12
> 
> D. 15
### 解
> [!done]+
> 本题选 **B**。
### 解
> [!done]+
> **方法一：计算 next 数组**
> 
> 根据《数据结构（C 语言版）》next 数组默认下标从 1 开始。
> 
> 第一步：计算出模式串的 next 数组。默认 next 数组是整体加 1 后的 next 数组。
> 
> 未整体加 1 的 next 数组：第一格负一，第二格零，前缀等于后缀取最长。
> 
> 整体加 1 后的 next 数组：第一格零，第二格一，前缀等于后缀取最长再加一。
> 
> 可计算出 next 数组如下：
> 
> <table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>下标 i</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr><tr><td>S[i]</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>c</td></tr><tr><td>未加一的 next[i]</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>2</td></tr><tr><td>加一后的 next[i]</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td></tr></tbody></table>
> 
> ![](https://pic3.zhimg.com/v2-dec6bc642a5e692b95e4dbe3d1461d00_r.jpg)
> 
> 第二步：遍历主串对模式串进行匹配。
> 
> 第一次匹配：在主串第六个位置出现失配，需要移动。
> 
> **移动位数 = 已匹配字符数 - 失配位置对应的匹配值（未整体加 1 的 next 数组）** = 5 - 2 = 3。模式串向后移动 3 格。
> 
> **移动位数 = 失配位置 - 失配位置对应的匹配值（整体加 1 后的 next 数组）** = 6 - 3 = 3。模式串向后移动 3 格。
> 
> 或指向模式串 S 的 **j 指针跳转指向模式串第 next[j] 个字符重新与主串第 i 个字符进行比较，**next[6] = 3 ， j 指针跳转到模式串第 3 个字符的位置。
> 
> 第二次匹配：匹配成功。
> 
> 匹配 9 次，失配 1 次，总比较次数：9+1=10。
> 
> 本题选 **B**。
> 
> **方法二：模拟**
> 
> 设模式为 $P[1:m]$ ，文本为 $T[1:n]$ ，初始时偏移为 _s_ = 0。
> 
> 设当前偏移为 _s_，需要从前往后依次比较 $P[1:m]$ 和 $T[1+s:m+s]$ ，若 $P[1:m]=T[1+s:m+s]$ ，则匹配成功，得到 _P_ 在 _T_ 中的一个匹配。
> 
> 若中间出现失配，设在 _P_ 的第 $i$ 个位置出现失配，即有 $P[i]\ne T[i+s]$ ，则需要利用已匹配部分 $P[1:i-1]$ 和 $T[1+s:i-1+s]$ 的信息。
> 
> 以下以 _T_ = bacbababaabcbab 和 _P_ = ababaca 为例。_P_ 中绿色（含浅绿色和深绿色）表示对应字符匹配，红色表示对应字符失配，灰色表示未比较，浅绿色表示已匹配部分的最长的相等的前缀，深绿色表示已匹配部分的最长的相等的后缀。_T_ 中黄色表示对应字符已经比较过，灰色表示未比较。
> 
> ![](https://picx.zhimg.com/v2-c8934defcf3ebe6884a318d43b098ccf_r.jpg)
> 
> 若已匹配部分为空，则 _P_ 继续偏移一个位置，即偏移 _s_ 增加 1。如图中第 1 趟、第 3 趟和第 4 趟匹配。
> 
> 若已匹配部分不为空，已匹配长度为 x = _i_ - 1，找出已匹配部分的最长的相等的前缀和后缀，（寻找已匹配部分的最长的相等的前缀和后缀时，从长度为 _x_ - 1 的前缀和后缀开始判断更好。）该长度为 _y_，则下一次匹配从后缀开始位置开始，即偏移 _s_ 增加 _x - y_。如图中第 2 趟和第 5 趟匹配。这步跳转用到了等式的传递性，因为 $P[1:y] = P[x-y+1:x]$ 且 $P[x-y+1:x] = T[x-y+1+s:x+s]$ ，所以 $P[1:y] = T[x-y+1+s:x+s]$ 。KMP 算法强大的地方就在这里，相比朴素字符串匹配算法，偏移 _s_ 不仅实现了跳跃式增长，而且下一趟匹配中当前这趟的前缀部分的无需重新比较。
> 
> 接下来进入下一轮匹配，从 _P_ 中未比较的灰色部分开始继续比较，重复上述过程直到找到一个匹配或者比较超出 _T_ 的范围为止。
> 
> 该模拟方法无需计算 next 数组，next 数组本质就是基于这个原理进行计算的。此外，由于 next 数组有多种计算方式，不同计算方式结果不同，并不方便真题进行考察。
> 
> ![](https://picx.zhimg.com/v2-7b4920d0098c41ac1123c177fe66c3d1_r.jpg)
> 
> 假设已经比较了 _k_ 趟。
> 
> $\begin{aligned} 总比较次数 &= \sum_{i=1}^{k}{第 i 趟比较次数}\\ &= \sum_{i=1}^{k}({第 i 趟比较后匹配次数+第 i 趟比较后失配次数})\\ &=(5 + 1) + (4 + 0) \\ &= 10 \end{aligned}$
> 
> 这里有个注意点，第 _i_ 趟比较后匹配次数不是第 _i_ 趟所有匹配的字符数，例如第 2 趟匹配中，前缀 ab 是无需重新比较的，所以第 2 趟比较后匹配次数 = 4，而不是 6，这一点一定要细心。
> 
> 还有一种更快捷的计算方法：
> 
> $\begin{aligned} 总比较次数 &= T中已经比较过的字符数+重复比较的字符数\\ &= 9+1\\ &= 10 \end{aligned}$
> 
> $重复比较次数 = 前 k-1 趟中在除 P 第一个字符位置外出现失配的次数$
> 
> 后一种计算方式更为简便。
> 
> 本题选 **B**。
> 
> **方法三：贪心**
> 
> 贪心找到最多匹配的情况，同样画出上图。虽然这个方法不严谨，好在本题足够简单，只有开始头指针对齐的一次和完全匹配的一次，总共出现一次失配。
> 
> 匹配 9 次，失配 1 次，总比较次数：9+1=10。
> 
> 本题选 **B**。