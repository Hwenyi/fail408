---
publish: true
tags: 
aliases: 
finished: true
title: 题39
created: "2024-11-21 06:44"
updated: "2024-11-21 07:40"
---
## 题39
### 题目
> [!question]+
> 主机甲和主机乙新建一个 TCP 连接，甲的拥塞控制初始阈值为 32 KB，甲向乙始终以 MSS=1 KB 大小的段发送数据，并一直有数据发送；乙为该连接分配 16 KB 接收缓存，并对每个数据段进行确认，忽略段传输延迟。若乙收到的数据全部存入缓存，不被取走，则甲从连接建立成功时刻起，未发生超时的情况下，经过 4 个 RTT 后，甲的发送窗口是（ ）。
> 
> A. 1 KB
> 
> B. 8 KB
> 
> C. 16 KB
> 
> D. 32 KB
### 解
> [!done]+
> 发送方发送窗口 swnd = min {拥塞窗口 cwnd, 接收方接收窗口 rwnd}。
> 
> 乙的 TCP 接收缓存仅有数据存入而无数据取出。根据题意，初始时，rwnd =16 KB。
> 
> 发送方维持一个拥塞窗口 (congestion window, cwnd)，拥塞窗口的大小取决于网络的拥塞程度，并且动态地变化。发送方让自己的发送窗口等于拥塞窗口。
> 
> 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。
> 
> 最大报文段长度 (maximum segment size, MSS) 是 TCP 协议的一个选项，用于在 TCP 连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度（不包括报文段头）。
> 
> **慢开始算法**
> 
> ![](https://picx.zhimg.com/v2-54cf2f70f8ec671aba06602ea7635507_r.jpg)
> 
> 开始时，将拥塞窗口设置为一个 MSS 的数值，每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个 MSS 的数值。可以分析出，每经过一个传输轮次 (transmission round)，拥塞窗口大小加倍，逐渐增大到拥塞窗口的数值，一个传输轮次所经历的时间就是一个往返时间 RTT。
> 
> **拥塞避免算法**
> 
> ![](https://pic4.zhimg.com/v2-7b66ffe1c7cb29ec94082340ca704bf9_r.jpg)
> 
> 每经过一个往返时间将发送方的窗口加 1。只要发送方判断网络出现拥塞，就将慢开始门限 ssthresh 设置为出现拥塞时发送方窗口值的一半，然后执行慢开始算法。
> 
> <table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td></td><td>发送方每收到一个对新的报文段的确认后拥塞窗口大小变化</td><td>发送方每经过一个轮次后拥塞窗口大小变化</td></tr><tr><td>慢开始算法</td><td>拥塞窗口大小增加至多 1 个 MSS。若拥塞窗口大小未达到拥塞窗口阈值，则拥塞窗口大小增加 1 个 MSS；若拥塞窗口大小达到拥塞窗口阈值，则拥塞窗口大小不变。</td><td>本轮次拥塞窗口大小是上一个轮次拥塞窗口大小的两倍且不超过拥塞窗口阈值。当前轮次的拥塞窗口 = min{2× 上一轮轮次的拥塞窗口, ssthresh}</td></tr><tr><td>拥塞避免算法</td><td>若已发送报文段不是该轮次最后一个报文段，则拥塞窗口大小不变；若已发送报文段是该轮次最后一个报文段，则拥塞窗口大小增加 1 个 MSS。</td><td>本轮次拥塞窗口大小在上一个轮次拥塞窗口大小的基础上增加 1 个 MSS。当前轮次的拥塞窗口 = 上一轮轮次的拥塞窗口 + 1</td></tr></tbody></table>
> 
> 接下来对本题进行分析。
> 
> 拥塞窗口初始阈值为 32 KB，乙的接受缓存为 16 KB，16 KB < 32 KB，即便在一个 RTT 中发送 16 KB 数据都不会触发拥塞避免算法。可以断言从主机甲发送第 1 个 TCP 段到主机甲收到的第 16 个确认段所通告时慢开始算法都适用，不会触发拥塞避免算法。
> 
> 采用慢开始算法。
> 
> 初始时，拥塞窗口 cwnd = 1KB，乙的接收窗口 rwnd = 16 KB。
> 
> 甲的发送窗口 swnd = min{cwnd, rwnd} = min {1 KB, 16 KB} = 1KB。
> 
> 第 1 个 RTT 开始时，可以将第 1 个 TCP 段连续发送出去，第 1 个 RTT 结束后，上述 TCP 段进入乙的缓存，乙的接收窗口 rwnd = 16 KB -1 KB = 15 KB，调整当前拥塞窗口大小为上一轮次拥塞窗口大小的两倍，拥塞窗口 cwnd = 2 KB。甲的发送窗口 swnd = min{cwnd, rwnd} = min {2 KB, 15 KB} = 2 KB。
> 
> 第 2 个 RTT 开始时，可以将第 2、3 个 TCP 段连续发送出去。第 2 个 RTT 结束后，上述 TCP 段进入乙的缓存，乙的接收窗口 rwnd = 15 KB -2 KB = 13 KB，调整当前拥塞窗口大小为上一轮次拥塞窗口大小的两倍，拥塞窗口 cwnd = 4 KB。甲的发送窗口 swnd = min{cwnd, rwnd} = min {4 KB, 13 KB} = 4 KB。
> 
> 第 3 个 RTT 开始时，可以将第 4、5、6、7 个 TCP 段连续发送出去。第 3 个 RTT 结束后，上述 TCP 段进入乙的缓存，乙的接收窗口 rwnd = 13 KB -4 KB = 9 KB，调整当前拥塞窗口大小为上一轮次拥塞窗口大小的两倍，拥塞窗口 cwnd = 8 KB。甲的发送窗口 swnd = min{cwnd, rwnd} = min {8 KB, 9 KB} = 8 KB。
> 
> 第 4 个 RTT 开始时，可以将第 8、9、10、11、12、13、14、15 个 TCP 段连续发送出去。第 4 个 RTT 结束后，上述 TCP 段进入乙的缓存，乙的接收窗口 rwnd = 9 KB - 8 KB = 1 KB，调整当前拥塞窗口大小为上一轮次拥塞窗口大小的两倍，拥塞窗口 cwnd = 16 KB。甲的发送窗口 swnd = min{cwnd, rwnd} = min {16 KB, 1 KB} = 1 KB。
> 
> 为了简化模型，假设同一个 TCP 段的发送和确认在同一个 RTT 内完成，可画出如下示意图。
> 
> ![](https://picx.zhimg.com/v2-17780752217a694b73fb78ddc26c7079_r.jpg)
> 
> 本题选 A。